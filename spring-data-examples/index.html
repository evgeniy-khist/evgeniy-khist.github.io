<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Spring Data JPA pitfalls and modern alternatives: Spring Data JDBC and Spring Data R2DBC</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css" />
  <link rel="stylesheet" href="/css/prism.min.css" />

  <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
  <script async defer src="https://buttons.github.io/buttons.js"></script>
  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script>
    
  <script>
    $(document).ready(function () {
      $(".navbar-burger").click(function () {
        $(".navbar-burger").toggleClass("is-active");
        $(".navbar-menu").toggleClass("is-active");
      });
    });
  </script>
</head>

<body>
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://github.com/evgeniy-khist" target="_blank">
        <span class="tag is-link is-medium">
          <span class="icon">
            <i class="fab fa-github"></i>
          </span>
          <span> evgeniy-khist</span>
        </span>
      </a>

      <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navMenu">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navMenu" class="navbar-menu">
      <div class="navbar-start">
        <a class="navbar-item" href="/">
          Home
        </a>

        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link">
            Projects
          </a>

          <div class="navbar-dropdown">
              <a class="navbar-item" href="/spring-data-examples/">
                Spring Data JPA pitfalls and modern alternatives: Spring Data JDBC and Spring Data R2DBC
              </a>
              <a class="navbar-item" href="/postgresql-performance-essentials/">
                PostgreSQL Performance Essentials in 1 Hour
              </a>
              <a class="navbar-item" href="/eventstoredb-event-sourcing/">
                Event Sourcing with EventStoreDB
              </a>
              <a class="navbar-item" href="/postgresql-event-sourcing/">
                Event Sourcing with PostgreSQL
              </a>
              <a class="navbar-item" href="/ksqldb-event-souring/">
                Event Sourcing with Kafka and ksqlDB
              </a>
              <a class="navbar-item" href="/spring-kafka-non-blocking-retries-and-dlt/">
                Spring Kafka Non-Blocking Retries and Dead Letter Topics
              </a>
              <a class="navbar-item" href="/geohash-example/">
                Rents Map - Geohash Example
              </a>
              <a class="navbar-item" href="/pairwise-comparison/">
                Pairwise Comparison Method
              </a>
              <a class="navbar-item" href="/letsencrypt-docker-compose/">
                Nginx and Letâ€™s Encrypt with Docker Compose in less than 3 minutes
              </a>
          </div>
        </div>
      </div>

      <div class="navbar-end">
        <div class="navbar-item">
          <a class="github-button" href="https://github.com/evgeniy-khist" data-size="large" data-show-count="true"
            aria-label="Follow @evgeniy-khist on GitHub">Follow @evgeniy-khist</a>
        </div>
      </div>
    </div>
  </nav>

  <section class="hero is-light">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">
          Evgeniy Khyst's Tech Blog
        </h1>
        <h2 class="subtitle">
          Samples and articles
        </h2>
      </div>
    </div>
  </section>

  <section class="section">
    <div class="container">
<div class="columns">
  <div class="column">
    <a class="github-button" href="https://github.com/evgeniy-khist/spring-data-examples" data-icon="octicon-star"
      data-size="large" data-show-count="true" aria-label="Star evgeniy-khist/spring-data-examples on GitHub">Star</a>
    <a class="github-button" href="https://github.com/evgeniy-khist/spring-data-examples/fork" data-icon="octicon-repo-forked"
      data-size="large" data-show-count="true" aria-label="Fork evgeniy-khist/spring-data-examples on GitHub">Fork</a>
  </div>
  <div class="column has-text-right has-text-grey">
    <time datetime="2021-05-04">4 May 2021</time>
  </div>
</div>

<div class="content">
<h1>Spring Data JPA pitfalls and modern alternatives: Spring Data JDBC and Spring Data R2DBC</h1>
<ul>
<li><a href="#3b878279a04dc47d60932cb294d96259">Overview</a></li>
<li><a href="#810bf4be9fd3907b3e5cff790716a958">Spring Data JPA</a>
<ul>
<li><a href="#75e0f07fedd63771fc35ec852a9c937f">Fetching strategies</a></li>
<li><a href="#9a3347442ef97064c198bda69c16f816">Locking strategies</a></li>
<li><a href="#6066f586527da9c5d0e297396ca12e5e">Entity to DTO mapping</a></li>
</ul>
</li>
<li><a href="#86e43ec88f085c89356cfb650c7d5ce7">Spring Data JDBC</a></li>
<li><a href="#afa7b6461a2e3f16a1895d95522f3f29">Spring Data R2DBC</a></li>
<li><a href="#6f8b794f3246b0c1e1780bb4d4d5dc53">Conclusion</a></li>
<li><a href="#e930cfb2216d9b0871311eeabd12ef12">Spring Data JPA example</a>
<ul>
<li><a href="#ca1ea02c10b7c37f425b9b7dd86d5e11">Test data</a></li>
<li><a href="#75e0f07fedd63771fc35ec852a9c937f">Fetching strategies</a>
<ul>
<li><a href="#7ea24578e6c11808b7b2880dd98bc573">Entity without explicit <code>@Fetch</code></a>
<ul>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#ecfc45d33505baec3249b78ec3e66059">Query method</a></li>
<li><a href="#957184c667a66fa2409d3c81d58e0f90">Query method with <code>@EntityGraph</code></a></li>
<li><a href="#ce895104ae9e9dd02aafbba89a339104">Query method with <code>@EntityGraph</code> and <code>Pageable</code></a></li>
<li><a href="#260b142dfcc1f303ff3e67de6da4d730">Query method with <code>@EntityGraph</code> with multiple attribute nodes (issue HHH-13740)</a></li>
<li><a href="#99fac513c058317164ad5a6e20d34f18"><code>@Query</code> with JPQL <code>join fetch</code></a></li>
<li><a href="#ff9705f518ec48b7fa77d2d6cd0c3c14"><code>@Query</code> with JPQL <code>join fetch</code> and <code>distinct</code></a></li>
<li><a href="#e11be536b6f6d686f69f20513138cae0">Custom <code>@Repository</code> with Criteria API query</a></li>
<li><a href="#1323d64c9e1914e06c3b257f7cea728c">Custom <code>@Repository</code> with Criteria API query with <code>fetch</code></a></li>
<li><a href="#7285e9899741d937830c2225ff8d01bc">Custom <code>@Repository</code> with Criteria API query with <code>fetch</code> and <code>distinct</code></a></li>
</ul>
</li>
<li><a href="#239f2f55854878f99d5d4d379a765d39">Entity with <code>@Fetch(JOIN)</code></a>
<ul>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#ecfc45d33505baec3249b78ec3e66059">Query method</a></li>
</ul>
</li>
<li><a href="#61d561e02c4002d6d6ad4646e5d328f7">Entity with <code>@Fetch(SELECT)</code></a>
<ul>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#ecfc45d33505baec3249b78ec3e66059">Query method</a></li>
</ul>
</li>
<li><a href="#76b5b36ea931f6c209971594a5473ffa">Entity with <code>@Fetch(SUBSELECT)</code></a>
<ul>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#ecfc45d33505baec3249b78ec3e66059">Query method</a></li>
</ul>
</li>
<li><a href="#b77feec501b1fe41ebee44d25e206880">Entity with <code>@BatchSize</code></a>
<ul>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#ecfc45d33505baec3249b78ec3e66059">Query method</a></li>
</ul>
</li>
<li><a href="#1049387d75c060dc77f67c5477fb48d4">Entity with multiple bags resulting in <code>MultipleBagFetchException</code></a></li>
</ul>
</li>
<li><a href="#9a3347442ef97064c198bda69c16f816">Locking strategies</a>
<ul>
<li><a href="#272ede57357a5f214f2904c15e3fe103">Implicit optimistic lock of entity with <code>@Version</code> on modification</a></li>
<li><a href="#502c2256dbc0a223143500d9f9b3b5cc">Explicit optimistic lock <code>@Lock(OPTIMISTIC)</code></a></li>
<li><a href="#6efaef54090120ae008692898745a547">Explicit optimistic lock <code>@Lock(OPTIMISTIC_FORCE_INCREMENT)</code></a></li>
<li><a href="#c2b4e4a7c69f6c6b216e05a547731c57">Explicit pessimistic write lock <code>@Lock(PESSIMISTIC_WRITE)</code></a></li>
<li><a href="#657a4b524b13a122706ee27f7675bcf7">Explicit pessimistic read lock <code>@Lock(PESSIMISTIC_READ)</code></a></li>
</ul>
</li>
<li><a href="#532d5a8c2809912b992aa517d1e46ced">Mapping from entity to DTO using MapStruct</a></li>
</ul>
</li>
<li><a href="#1ef62fd469285970a640c75be1cbdb9a">Spring Data JDBC example</a>
<ul>
<li><a href="#ca1ea02c10b7c37f425b9b7dd86d5e11">Test data</a></li>
<li><a href="#cf43137803fb51915f84cbc5c3068d34">Queries</a>
<ul>
<li><a href="#07109b7f3df585c23975718b13843dac"><code>CrudRepository.save</code></a></li>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#f34c8b22bd6fb5a16c60b7ecd412d675"><code>PagingAndSortingRepository.findAll(Pageable)</code></a></li>
<li><a href="#fe9f09d7c10598e080ef1ac1502711df"><code>@Query</code> with SQL</a></li>
<li><a href="#ce75f4a17b574599267b2a18924cb931"><code>@Query</code> with SQL join</a></li>
<li><a href="#59581bf130250c31253eac07da3d2c56"><code>@Query</code> with SQL and pagination</a></li>
</ul>
</li>
<li><a href="#9a3347442ef97064c198bda69c16f816">Locking strategies</a>
<ul>
<li><a href="#272ede57357a5f214f2904c15e3fe103">Implicit optimistic lock of entity with <code>@Version</code> on modification</a></li>
</ul>
</li>
<li><a href="#532d5a8c2809912b992aa517d1e46ced">Mapping from entity to DTO using MapStruct</a></li>
<li><a href="#fc1290b67d538903eba761ca9f952dc9">Reactive <code>Mono.fromCallable</code> wrapping synchronous call</a></li>
</ul>
</li>
<li><a href="#1418b03e9a73d96a8c697855b6c0401e">Spring Data R2DBC example</a>
<ul>
<li><a href="#cf43137803fb51915f84cbc5c3068d34">Queries</a>
<ul>
<li><a href="#4a2070d3aad7ff832b5e36f76cc6f731"><code>CrudRepository.findById</code></a></li>
<li><a href="#74790cb9ca9d56e09b465befb7c7603b">Query method with <code>Sort</code></a></li>
<li><a href="#59581bf130250c31253eac07da3d2c56"><code>@Query</code> with SQL and pagination</a></li>
<li><a href="#532d5a8c2809912b992aa517d1e46ced">Mapping from entity to DTO using MapStruct</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a name="3b878279a04dc47d60932cb294d96259"></a>Overview</h2>
<p>These examples demonstrates some common JPA pitfalls and evaluates alternatives from the Spring Data family:</p>
<ul>
<li><a href="spring-data-jpa-examples/">spring-data-jpa-examples</a> - some of common JPA pitfalls</li>
<li><a href="spring-data-jdbc-examples/">spring-data-jdbc-examples</a> - Spring Data JDBC as a simpler alternative inspired by Domain-Driven Design</li>
<li><a href="spring-data-r2dbc-examples/">spring-data-r2dbc-examples</a> - Spring Data R2DBC for reactive database connectivity</li>
</ul>
<p>Spring Data is a family of libraries aiming to simplify the implementation of a data access layer for Spring-based applications by reducing boilerplate code.
Spring Data makes it easy to implement a Repository for accessing persistent entities in the underlying data store.
Spring Data JPA allows to build repositories based on JPA.</p>
<p>JPA (Java Persistence API) is an API specification that defines an ORM (object-relational mapping) standard for Java applications.
The most popular JPA vendor is Hibernate ORM.
JPA 1.0 was released in 2006, and the latest (at the time of writing) versions are JPA 2.2 and Hibernate ORM 5.4.14.Final.
JPA and Hibernate are de facto a standard way of implementing a data access layer in Java applications.</p>
<p>All these years JPA and Hibernate are criticized for being too complicated.
Trying to operate with database records like with objects and completely hide the relational nature of a database,
JPA introduces some complexity:
detaching and merging entities, first-level cache, lazy loading, dirty checking, and many other features.
More importantly, in the JPA, many DB calls are made behind the scenes.
A simple query sometimes leads to multiple SQL queries to a DB.
In its turn, too many SQL queries leads to performance problems.</p>
<h2><a name="810bf4be9fd3907b3e5cff790716a958"></a>Spring Data JPA</h2>
<p>Spring Data JPA allows writing less boilerplate code, but JPA and Hibernate still have many pitfalls.
The ones described in this example, I consider the most common pitfalls.</p>
<p>Thus, <a href="spring-data-jpa-examples/">spring-data-jpa-examples</a> demonstrate and analyze the following JPA-related topics:</p>
<ul>
<li>fetching strategies of <code>@OneToMany</code> and <code>@ManyToMany</code> collections</li>
<li>locking strategies</li>
<li>entity to DTO mapping</li>
</ul>
<h3><a name="75e0f07fedd63771fc35ec852a9c937f"></a>Fetching strategies</h3>
<p>An entity can reference others called child entities.
When fetching an entity, should Hibernate also fetch child entities?
How to fetch child entities, in a separate query, or the same query by joining related tables etc.?</p>
<p>JPA and Hibernate have different fetch types, fetch modes.
Some of them can cause problems if used improperly.</p>
<p>One-to-many and many-to-many relationships are mapped to fields of a class of types <code>List</code> and <code>Set</code>
annotated with JPA annotations <code>@OneToMany</code> or <code>@ManyToMany</code>.
These annotations have parameter <code>fetch</code> of type <code>javax.persistence.FetchType</code>.</p>
<p>There are also Hibernate-specific annotation <code>@Fetch</code> with parameter <code>value</code> of type <code>org.hibernate.annotations.FetchMode</code>
and <code>@BatchSize</code> that define how a child entity fetching is done.</p>
<p><code>javax.persistence.FetchType</code> defines <strong>when</strong> the fetching is done
while <code>org.hibernate.annotations.FetchMode</code> focuses on <strong>how</strong>.</p>
<p>There are 2 <code>FetchType</code> values:</p>
<ul>
<li><code>EAGER</code> - load a child entity at the same time when the parent entity is loaded but not necessarily in a single SQL query.</li>
<li><code>LAZY</code> - postpone a child entity loading and fetch on the first access. So, if a field was never accessed,
it's not fetched at all.</li>
</ul>
<p>Be default, Hibernate lazily loads child collections (<code>@OneToMany</code> and <code>@ManyToMany</code>).
This is optimal for the majority of cases.</p>
<p>There are 3 <code>FetchMode</code> values:</p>
<ul>
<li><code>SELECT</code> - fetch each child collection using an additional <code>SELECT</code> SQL query per parent entity.
If a query returns N entities with 2 child collections, together with the main query,
there will be 1 + N * 2 <code>SELECT</code> queries in total.</li>
<li><code>JOIN</code> - fetch in a single query together with a parent entity using SQL <code>JOIN</code>.
Joining a parent entity with child collections results in duplicates in the query result set.</li>
<li><code>SUBSELECT</code> - fetch each child collection for all parent entities in a single SQL query.
If a query returns N entities with 2 child collections, together with the main query,
there will be 3 (1 + 2) <code>SELECT</code> queries.</li>
</ul>
<p>If a field is not annotated with <code>@Fetch</code>, then the default <code>FetchMode</code> for this field depends on a <code>FetchType</code> and how the query is done:</p>
<ul>
<li><code>FetchType.LAZY</code> - <code>FetchMode.SELECT</code></li>
<li><code>FetchType.EAGER</code>:
<ul>
<li>getting by ID - <code>FetchMode.JOIN</code></li>
<li>JPQL query - <code>FetchMode.SELECT</code></li>
<li>Criteria API query - <code>FetchMode.SELECT</code></li>
</ul>
</li>
</ul>
<p><code>@BatchSize</code> annotation defines size for batch loading of child collections.<br>
If a query returns N entities with 2 child collections, together with the main query,
there will be 1 + ceil(N / batchSize) * 2 <code>SELECT</code> queries in total.
Child collection for the first 2 parent entities are loaded in the first query, for the next 2 parent entities in second query etc.</p>
<p>Why do we need so many options to control the fetching of child collections?
Why can't we always use <code>FetchMode.SELECT</code>?</p>
<p>It is related to so called &quot;N+1 selects&quot; problem.
When <code>FetchMode.SELECT</code> is used, Hibernate fetches associated collections using a separate SQL <code>SELECT</code> query.
The first SQL query selects parent (root) entities only.
Each associated collection is loaded with a separate SQL query.
Thus, Hibernate makes N+1 SQL queries, where N is the number of parent (root) entities in the result set.</p>
<p>Find out more about &quot;N+1 selects&quot; problem and other database-related performance problems in the <a href="https://www.slideshare.net/EvgeniyKhist/application-performance-databaserelated-problems">slides</a>.</p>
<p><a href="https://www.slideshare.net/EvgeniyKhist/application-performance-databaserelated-problems"><img src="img/application-performance-database-related-problems.png" alt="The slides on SlideShare"></a></p>
<p>Solutions to &quot;N+1 selects&quot; problem:</p>
<ul>
<li><code>FetchMode.JOIN</code></li>
<li><code>FetchMode.SUBSELECT</code></li>
<li><code>@BatchSize</code></li>
<li><code>@EntityGraph</code></li>
<li>JPQL <code>join fetch</code></li>
<li>Criteria API <code>fetch</code></li>
</ul>
<p><code>FetchMode.JOIN</code> has no effect on JPQL queries.
So, use it to get entity by ID (<code>CrudRepository.findById</code>).
Be ready to handle duplicates in the result set due to joining a parent entity table with child collection table.</p>
<p><code>FetchMode.SUBSELECT</code> makes Hibernate fetch all child entities for all parent entities from the result set using a single SQL query with original query as sub-select:</p>
<pre><code class="language-sql">SELECT * FROM Parent
SELECT * FROM Child WHERE parentId IN (SELECT id FROM Parent)
</code></pre>
<p>But there is a pitfall.
If a query has pagination (offset and limit), Hibernate doesn't include it in the sub-select:</p>
<pre><code class="language-sql">SELECT * FROM Parent LIMIT 2
SELECT * FROM Child WHERE parentId IN (SELECT id FROM Parent)
</code></pre>
<p>It may result in loading all child entities (depending on the data set even millions) into the memory even if only few of them are required.
It can consume a lot of memory what is unexpected.</p>
<p><code>@BatchSize</code> is a compromise between <code>FetchMode.SELECT</code> and <code>FetchMode.SUBSELECT</code>.
With <code>@BatchSize(size = batchSize)</code> Hibernate generates (1 + ceil(N / batchSize)).
With a result set of size 2 and <code>@BatchSize(size = 2)</code>, 3 queries are executed.</p>
<pre><code class="language-sql">SELECT * FROM Parent LIMIT 2
SELECT * FROM Child WHERE parentId IN (?, ?)
SELECT * FROM Child WHERE parentId IN (?, ?)
...
</code></pre>
<p>Increasing batch size adds more values to the <code>IN</code> clause.
Remember that Oracle database has limitation of 1000 items in <code>IN</code> clause.
So, <code>@BatchSize</code> looks like the most safe solution for generic cases.</p>
<p>Find out more details in the <a href="#springdatajpaexample">example</a>.</p>
<h3><a name="9a3347442ef97064c198bda69c16f816"></a>Locking strategies</h3>
<p>Locks are mechanisms that prevent destructive interaction between transactions accessing the same resource.</p>
<p>A transaction always gets an exclusive lock on any data it modifies and holds that lock until the transaction completes,
regardless of the <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">isolation level</a> set for the transaction.</p>
<p>Read committed is a default isolation for most JDBC drivers.</p>
<p>For read operations transaction isolation levels primarily define the level of protection from the effects of modification made by other transactions.
In read committed reads are not blocking.</p>
<p>Exclusive lock on a record can be acquired using:</p>
<ul>
<li><code>UPDATE tbl SET col1 = 'new value'</code></li>
<li><code>SELECT col1 FROM tbl FOR UPDATE</code></li>
</ul>
<p>Shared lock on a record in PostgreSQL can be acquired using:</p>
<ul>
<li><code>SELECT col1 FROM tbl FOR SHARE</code></li>
</ul>
<p>Records locked with <code>SELECT FOR UPDATE</code> are protected from modifications by other transactions.
Transactions trying to <code>UPDATE</code>, <code>DELETE</code>, <code>SELECT FOR UPDATE</code>, <code>SELECT FOR SHARE</code> are locked,
until the end of the current transaction.</p>
<p>Records locked with <code>SELECT FOR SHARE</code> are protected from <code>UPDATE</code>, <code>DELETE</code>, <code>SELECT FOR UPDATE</code> from other transactions
but <code>SELECT FOR SHARE</code> is allowed.</p>
<p>There are pessimistic and optimistic locking concurrency control mechanisms.</p>
<p>Pessimistic locking is a strategy when you lock a record when reading and then modify:</p>
<pre><code class="language-sql">SELECT col1 FROM tbl FOR UPDATE;
...
UPDATE tbl SET col1 = 'new value';
</code></pre>
<p>Optimistic locking is a strategy when you read record with version number and then check this version for updating:</p>
<pre><code class="language-sql">SELECT col1, version FROM tbl;
...
UPDATE tbl SET col1 = 'new value', version = version + 1 WHERE version = :version;
</code></pre>
<p>Table should have column to store version.
Update of the row is done with version checking.
If row version has already changed in other transaction, changes of current transaction are discarded and whole transaction should be repeated.</p>
<pre><code>the first transaction started            |
                                         | the second transaction started
SELECT * FROM tbl WHERE id=1 --version=1 |
                                         | SELECT * FROM tbl WHERE id=1 --version=1 
UPDATE tbl SET val='new val', version=2  | 
 WHERE id=1 AND version=1                |
                                         | UPDATE tbl SET val='new val', version=2
                                         |  WHERE id=1 AND version=1
                                         | waiting to obtain update lock...
                                         | waiting to obtain update lock...
commit transaction                       | 
                                         | No rows were updated
                                         |  because version=2 after commit of the first transaction
                                         | 
                                         | optimistic locking exception is raised
                                         |
                                         | rollback transaction
</code></pre>
<p>If version check is optimistic locking fails, read and update queries should be re-executed.</p>
<p>Pessimistic locking prevents lost updates and makes updates serial (FIFO) reducing throughput.
Optimistic locking just prevents lost updates.</p>
<p>Optimistic locking allows to reduce time the lock is held and sometimes increases throughput.</p>
<p>Find out more about reducing lock contention and other database-related performance problems in the <a href="https://www.slideshare.net/EvgeniyKhist/application-performance-databaserelated-problems">slides</a>.</p>
<p>If an entity has a field annotated with <code>@Version</code>, optimistic locking is enabled by default if the entity was modified, even without explicitly specifying <code>LockModeType</code>.
But if the entity was not modified, there will be no version check before transaction commit.</p>
<p>JPA has the following <code>javax.persistence.LockModeType</code> values:</p>
<ul>
<li><code>OPTIMISTIC</code> - if an entity was not modified, and a version check can't be done in an <code>UPDATE</code>, it is still done before a transaction commit using a simple <code>SELECT version FROM tbl</code></li>
<li><code>OPTIMISTIC_FORCE_INCREMENT</code> - a version is incremented using an <code>UPDATE tlb SET version = version + 1</code> even if an entity was not modified</li>
<li><code>PESSIMISTIC_WRITE</code> - a record is locked using a <code>SELECT FOR UPDATE</code></li>
<li><code>PESSIMISTIC_READ</code> - a record is locked using a <code>SELECT FOR SHARE</code> in PostgreSQL and <code>SELECT FOR UPDATE</code> in databases without shared row-level locks</li>
</ul>
<p><code>LockModeType.OPTIMISTIC</code> has a pitfall. If locked entity was not changed, Hibernate just checks version using simple <code>SELECT</code>.
If version was changed by another committed transaction, an <code>OptimisticLockException</code> exception is raised.
But between <code>SELECT</code> doing version check, and a commit of the current transaction there is a small time gap.
There is a risk that during this time another transaction still can change this entity.</p>
<p>Find out more details in the <a href="#springdatajpaexample">example</a>.</p>
<h3><a name="6066f586527da9c5d0e297396ca12e5e"></a>Entity to DTO mapping</h3>
<p>Exposing JPA entities in a REST API can cause problems.
Instead, map entities to DTOs and expose them.</p>
<p>What is the difference between an entity and a DTO?</p>
<p>A JPA entity (<code>@Entity</code>) is persisted and has to correspond to the underlying database table structure.
JPA doesn't enforce modelling entities as Aggregates described in the book Domain-driven design (DDD) by Eric Evans.
Anyway, JPA entity is a part of a business domain with a structure influenced by the underlying DB schema.</p>
<p>A DTO is used to transfer data from a supplier to a consumer.
A structure of DTO is dictated by the consumer.
DTO contains fields the consumer needs.<br>
DTO can have data duplication (denormalized) what is usually avoided in entities (normalization).
A single DTO can be composed of multiple entities or can be very similar to an entity.</p>
<p>So, it is clear, that if our REST API response need to be composed of multiple entities,
we need to use DTOs.
But do we need DTOs if our REST API response is similar or even identical to the JPA entity structure?</p>
<p>Yes, we need DTOs even if initially the JPA entity and DTO fields are identical because:</p>
<ul>
<li>entity can have bidirectional associations leading to cycles in object graphs (a workaround is <code>@JsonIgnore</code>)</li>
<li><code>LazyInitializationException</code> when serializing associations with <code>FetchType.LAZY</code></li>
<li>there's 99% chance that entity or DTO structure will change and become not identical</li>
</ul>
<p>To simplify entity to DTO mapping I recommend <a href="https://mapstruct.org/">MapStruct</a> library.
Unlike most other bean mapping tools, MapStruct doesnâ€™t work at runtime but is a compile-time code generator.
It generates the mapper class at the compile time.</p>
<p>Find out more details in the <a href="#springdatajpaexample">example</a>.</p>
<h2><a name="86e43ec88f085c89356cfb650c7d5ce7"></a>Spring Data JDBC</h2>
<p>In the previous section we've found out that JPA and Hibernate has a lot of pitfalls and is complicated.</p>
<p>Are there an alternative to Spring Data JPA?
Yes. There is Spring Data JDBC. The latest (at the time of writing) version is 2.0.0.RC1.</p>
<p>Is it a full-fledged replacement of Spring Data JPA?
Let's try to figure it out.</p>
<p>Spring Data JDBC is inspired by Aggregate Roots and Repositories as described in the book Domain-driven design (DDD) by Eric Evans.
Aggregate Root is an entity that controls the lifecycle of related entities forming together an Aggregate.
Each Aggregate has only one Aggregate Root.
You should have a Repository per Aggregate Root.
Related entities (one-to-one and one-to-many relationships) doesn't exist alone without an Aggregate Root.
When an Aggregate Root is deleted, all related entities get deleted too.</p>
<p>If two entities have different life-cycles these are separate Aggregate Roots.
Thus, in contrast to JPA, one-to-many (between different Aggregates) and many-to-many relationships must be modeled by referencing the ID<br>
and join tables for many-to-many relationships must be mapped to a Java class and added to an Aggregate.</p>
<p>Spring Data JDBC enforces us to model entities like Aggregates.
Also, entities can be truly immutable Java classes what is hard to achieve with JPA.</p>
<p>Spring Data JDBC has only one strategy for fetching child entities.
Separate queries are generated for child collections (maps, lists, sets and arrays of entities).</p>
<p>Comparing with Hibernate, Spring Data JDBC has fetching strategy <code>FetchType.EAGER</code> and <code>FetchMode.SELECT</code>.
Lazy loading of child collections is not supported.
Also, there is no sense in joining parent and child entities tables in SQL query.
It produces duplicates in the result set while Spring Data JDBC still makes additional queries for child collections.</p>
<p>So, Spring Data JDBC is also subject to &quot;N+1 selects&quot; problem.</p>
<p>Spring Data JDBC supports optimistic locking by using <code>org.springframework.data.annotation.Version</code> annotation.
The behaviour is similar to JPA with <code>javax.persistence.Version</code> annotation.</p>
<p>Spring Data JDBC still misses some useful features like pagination for custom queries.</p>
<p>Nowadays reactive, non-blocking, event-driven applications is a trend.
Spring WebFlux is reactive and uses non-blocking I/O in contrast to Spring MVC that is based on Servlet API and uses traditional blocking I/O.
A fully reactive application has better throughput (but not the latency) in most cases,
and utilizes resources more efficiently, resulting in a smaller memory footprint for handling concurrent requests.
If the entire application is reactive and based on non-blocking I/O from the database to REST API,
the performance might be better.</p>
<p>Is it possible to use Spring Data JDBC with Spring WebFlux?
Spring Data JDBC doesn't support <code>org.springframework.data.repository.reactive.ReactiveCrudRepository</code> directly.
To get reactive types <code>reactor.core.publisher.Mono</code> and <code>reactor.core.publisher.Flux</code>,
a blocking JDBC calls should be wrapped:</p>
<pre><code class="language-java">Mono&lt;Book&gt; blockingWrapper = Mono.fromCallable(() -&gt;
        entityRepository.findById(1).orElse(null))
        .subscribeOn(Schedulers.boundedElastic());
</code></pre>
<p>Find out more details in the example.</p>
<h2><a name="afa7b6461a2e3f16a1895d95522f3f29"></a>Spring Data R2DBC</h2>
<p>Spring Data JDBC is simpler than JPA and has fewer pitfalls.
But it would be good to have a truly reactive non-blocking data access layer.
That's where Spring Data R2DBC comes in.
The latest (at the time of writing) version is Spring Data R2DBC 1.1.0.RC1.</p>
<p>Spring Data R2DBC uses Reactive Relational Database Connectivity, a reactive programming APIs to relational databases.
In contrast to the blocking nature of JDBC, R2DBC is non-blocking and has a reactive API.
R2DBC drivers are available for:</p>
<ul>
<li>PostgreSQL</li>
<li>MySQL</li>
<li>MS SQL</li>
<li>H2</li>
</ul>
<p>Spring Data R2DBC used together with Spring WebFlux allows to develop fully-reactive and non-blocking applications.</p>
<p>Spring Data R2DBC concept is to be a simple and easy to use object mapper and
does <strong>NOT</strong> provide many features of ORM.</p>
<p>One-to-one, one-to-many and many-to-many relationships are not supported.</p>
<p>Thus, in contrast to JPA, relationships must be modeled by referencing the ID
and join tables for many-to-many relationships must be mapped to a Java class.</p>
<p>Spring Data R2DBC is raw and lack a lot of features. For example:</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-data-r2dbc/issues/99">R2DBC ORM Relationships Support</a></li>
<li><a href="https://github.com/spring-projects/spring-framework/issues/24226">https://github.com/spring-projects/spring-framework/issues/24226</a></li>
<li>Implicit pagination with <code>org.springframework.data.domain.Pageable</code> is not supported</li>
</ul>
<p>Fetching associations and mapping to DTO are not easy tasks with Spring Data R2DBC.</p>
<p>Find out more details in the example.</p>
<h2><a name="6f8b794f3246b0c1e1780bb4d4d5dc53"></a>Conclusion</h2>
<p>Spring Data JPA dramatically reduces the amount of boilerplate code.
Anyway, JPA and Hibernate have a lot of pitfalls developers should be aware of.
Developers have a little control over SQL queries that Hibernate generates.
The result is &quot;N+1 selects&quot; problem or loading the whole database table into the memory.</p>
<p>Spring Data JDBC is a simpler alternative. It gives developers more control over SQL queries.
But it lacks a lot of features like implicit pagination and also is a subject to &quot;N+1 selects problem&quot;.
Spring Data JDBC is a good choice for a simple applications with a simple domain model.</p>
<p>Spring Data R2DBC is in active development and misses a lot of features but looks very promising.
The idea to have an entirely reactive Java application based on non-blocking I/O from the database to REST API, is very interesting.</p>
<p>So, in Spring Data family there is no production-ready alternative to Spring Data JPA for enterprise applications nowadays.</p>
<h2><a name="e930cfb2216d9b0871311eeabd12ef12"></a>Spring Data JPA example</h2>
<p><a href="spring-data-jpa-examples/">spring-data-jpa-examples</a> has a simple domain model.
A book has at least one author and belongs to at least one category.
A book can be rated. An average rating and a total number of ratings are tracked.</p>
<p><strong>Simplified UML class diagram</strong></p>
<p><img src="spring-data-jpa-examples/img/classes_simplified.png" alt="Simplified UML class diagram"></p>
<p>Many-to-many relationship <code>List&lt;Author&gt; authors</code> has <code>javax.persistence.FetchType.EAGER</code>
and many-to-many relationship <code>Set&lt;Category&gt; categories</code> has <code>javax.persistence.FetchType.LAZY</code>.</p>
<p>To demonstrate how different <code>org.hibernate.annotations.FetchMode</code>s work
the hierarchy of book classes used:</p>
<ul>
<li><code>com.example.spring.data.jpa.entity.AbstractBook</code> - <code>@MappedSuperclass</code></li>
<li><code>com.example.spring.data.jpa.entity.Book</code> - no explicit <code>@Fetch</code></li>
<li><code>com.example.spring.data.jpa.entity.BookWithFetchModeJoin</code> - <code>@Fetch(JOIN)</code></li>
<li><code>com.example.spring.data.jpa.entity.BookWithFetchModeSelect</code> - <code>@Fetch(SELECT)</code></li>
<li><code>com.example.spring.data.jpa.entity.BookWithFetchModeSubselect</code> - <code>@Fetch(SUBSELECT)</code></li>
<li><code>com.example.spring.data.jpa.entity.BookWithBatchSize</code> - <code>@BatchSize</code></li>
<li><code>com.example.spring.data.jpa.entity.BookWithMultipleBags</code> - doesn't extend <code>AbstractBook</code> and has <code>List&lt;Category&gt; categories</code> instead of Set<Category> like in <code>AbstractBook</code> and its children what leads to <code>MultipleBagFetchException: cannot simultaneously fetch multiple bags</code> when both relations are fetched using join.</li>
</ul>
<p>To demonstrate locking strategies a <code>com.example.spring.data.jpa.entity.BookRating</code> class has <code>@Version int version</code> field.</p>
<p><strong>Actual UML class diagram</strong></p>
<p><img src="spring-data-jpa-examples/img/classes.png" alt="Actual UML class diagram"></p>
<p><strong>Entity-relationship diagram</strong></p>
<p><img src="spring-data-jpa-examples/img/tables.png" alt="Entity-relationship diagram"></p>
<p>The example uses <a href="https://www.testcontainers.org/">Testcontainers</a> library that manages Docker containers in JUnit tests.
This library starts a PostgreSQL Docker container for integration tests.
Using the same database in production and integration tests is a big advantage compared to using in-memory databases like H2 or HSQLDB.</p>
<h3><a name="ca1ea02c10b7c37f425b9b7dd86d5e11"></a>Test data</h3>
<p><code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">void saveCategories() {
  softwareDevelopment = new Category(&quot;Software development&quot;);
  systemDesign = new Category(&quot;System design&quot;);

  categoryRepository.saveAll(List.of(systemDesign, softwareDevelopment));
}

void saveAuthors() {
  erichGamma = new Author(&quot;Erich Gamma&quot;);
  richardHelm = new Author(&quot;Richard Helm&quot;);
  ralphJohnson = new Author(&quot;Ralph Johnson&quot;);
  johnVlissides = new Author(&quot;John Vlissides&quot;);

  martinFowler = new Author(&quot;Martin Fowler&quot;);

  gregorHohpe = new Author(&quot;Gregor Hohpe&quot;);
  bobbyWoolf = new Author(&quot;Bobby Woolf&quot;);

  authorRepository.saveAll(List.of(
      erichGamma, richardHelm, ralphJohnson, johnVlissides,
      martinFowler, gregorHohpe, bobbyWoolf));
}

void saveBooks() {
  gof = createBook();
  gof.setIsbn(&quot;978-0201633610&quot;);
  gof.setTitle(&quot;Design Patterns: Elements of Reusable Object-Oriented Software&quot;);
  gof.setPublicationDate(LocalDate.parse(&quot;1994-11-10&quot;));
  gof.getAuthors().addAll(List.of(erichGamma, richardHelm, ralphJohnson, johnVlissides));
  gof.getCategories().add(softwareDevelopment);

  poeaa = createBook();
  poeaa.setIsbn(&quot;007-6092019909&quot;);
  poeaa.setTitle(&quot;Patterns of Enterprise Application Architecture&quot;);
  poeaa.setPublicationDate(LocalDate.parse(&quot;2002-11-15&quot;));
  poeaa.getAuthors().add(martinFowler);
  poeaa.getCategories().addAll(List.of(softwareDevelopment, systemDesign));

  eip = createBook();
  eip.setIsbn(&quot;978-0321200686&quot;);
  eip.setTitle(&quot;Enterprise Integration Patterns&quot;);
  eip.setPublicationDate(LocalDate.parse(&quot;2003-10-20&quot;));
  eip.getAuthors().addAll(List.of(gregorHohpe, bobbyWoolf));
  eip.getCategories().addAll(List.of(softwareDevelopment, systemDesign));

  getBookRepository().saveAll(List.of(gof, poeaa, eip));
}
</code></pre>
<p><code>com.example.spring.data.jpa.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">book = new Book();
book.setIsbn(&quot;007-6092019909&quot;);
book.setTitle(&quot;Patterns of Enterprise Application Architecture&quot;);
book.setPublicationDate(LocalDate.parse(&quot;2002-11-15&quot;));
bookRepository.save(book);

rating = new BookRating();
rating.setBook(book);
rating.setRating(new BigDecimal(&quot;4.4&quot;));
rating.setNumberOfRatings(240);
bookRatingRepository.save(rating);
</code></pre>
<h3><a name="75e0f07fedd63771fc35ec852a9c937f"></a>Fetching strategies</h3>
<h4><a name="7ea24578e6c11808b7b2880dd98bc573"></a>Entity without explicit <code>@Fetch</code></h4>
<p><code>com.example.spring.data.jpa.entity.Book</code></p>
<pre><code class="language-java">@Entity
@Data
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
@ToString(callSuper = true)
public class Book extends AbstractBook {

  @ManyToMany(fetch = EAGER)
  private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

  @ManyToMany
  private Set&lt;Category&gt; categories = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<h5><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h5>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  Optional&lt;T&gt; poeaa = getBookRepository().findById(this.poeaa.getId());
  assertThat(poeaa).hasValueSatisfying(equalTo(this.poeaa));
}
</code></pre>
<p>2 SQL queries are executed.</p>
<ol>
<li>
<p>Select book and authors. When searching by ID using <code>CrudRepository.findById</code>, the default <code>FetchMode</code> for associations with <code>FetchType.EAGER</code> is <code>FetchMode.JOIN</code></p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_0_,
       book0_.isbn             AS isbn2_1_0_,
       book0_.publication_date AS publicat3_1_0_,
       book0_.title            AS title4_1_0_,
       authors1_.book_id       AS book_id1_2_1_,
       author2_.id             AS authors_2_2_1_,
       author2_.id             AS id1_0_2_,
       author2_.full_name      AS full_nam2_0_2_
FROM   book book0_
       LEFT OUTER JOIN book_authors authors1_
                    ON book0_.id = authors1_.book_id
       LEFT OUTER JOIN author author2_
                    ON authors1_.authors_id = author2_.id
WHERE  book0_.id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access. When searching by ID using <code>CrudRepository.findById</code>, the default <code>FetchMode</code> for associations with <code>FetchType.LAZY</code> is <code>FetchMode.SELECT</code></p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
</ol>
<h5><a name="ecfc45d33505baec3249b78ec3e66059"></a>Query method</h5>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code> extends <code>com.example.spring.data.jpa.repository.AbstractBookRepository</code></p>
<pre><code class="language-java">List&lt;T&gt; findByTitleContains(String title, Pageable pageable);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  List&lt;T&gt; books = getBookRepository()
      .findByTitleContains(&quot;Pattern&quot;, PageRequest.of(0, 2, DESC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.eip), atIndex(0))
      .satisfies(equalTo(this.poeaa), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 5 SQL queries are executed.</p>
<ol>
<li>
<p>Select books. <code>FetchType.EAGER</code> has no effect when query method is used (JPQL), so the <code>FetchMode.SELECT</code> is used for all associations</p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_,
       book0_.isbn             AS isbn2_1_,
       book0_.publication_date AS publicat3_1_,
       book0_.title            AS title4_1_
FROM   book book0_
WHERE  book0_.title LIKE ? escape ? /*%Pattern%,\*/
ORDER  BY book0_.publication_date DESC
LIMIT  ? /*2*/
</code></pre>
</li>
<li>
<p>Select authors for the 1st book from the result set. There will be a separate SQL query for each entity and its association from the result set (&quot;N+1 selects&quot; problem)</p>
<pre><code class="language-sql">SELECT authors0_.book_id    AS book_id1_2_0_,
       authors0_.authors_id AS authors_2_2_0_,
       author1_.id          AS id1_0_1_,
       author1_.full_name   AS full_nam2_0_1_
FROM   book_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Select authors for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_id    AS book_id1_2_0_,
       authors0_.authors_id AS authors_2_2_0_,
       author1_.id          AS id1_0_1_,
       author1_.full_name   AS full_nam2_0_1_
FROM   book_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_id = ? /*58*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
</ol>
<h5><a name="957184c667a66fa2409d3c81d58e0f90"></a>Query method with <code>@EntityGraph</code></h5>
<p>JPA 2.1 has introduced the Entity Graph feature as dynamic alternative to <code>FetchType.LAZY</code> and <code>FetchType.EAGER</code> that are static and can't be changed at runtime.
Entity Graph allows to specify what associations and basic fields have to loaded.
As mentioned above, <code>FetchType.EAGER</code> applied to child collections is ignored by JPQL queries.
So, Entity Graph is a solution for making Hibernate fetch child collections eagerly using SQL join.</p>
<p>The <code>javax.persistence.NamedEntityGraph</code> annotation allows specifying the attributes to include when loading the entity and its related associations.
Different query method can use different Entity Graphs, referencing them by name in <code>org.springframework.data.jpa.repository.EntityGraph</code> annotation.</p>
<p><code>com.example.spring.data.jpa.entity.Book</code></p>
<pre><code class="language-java">@NamedEntityGraph(name = &quot;Book.authors&quot;,
    attributeNodes = @NamedAttributeNode(&quot;authors&quot;)
)
</code></pre>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code></p>
<pre><code class="language-java">@EntityGraph(&quot;Book.authors&quot;)
List&lt;Book&gt; findByPublicationDateAfter(LocalDate date, Sort sort);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void entityGraph() {
  List&lt;Book&gt; books = bookRepository
      .findByPublicationDateAfter(LocalDate.parse(&quot;2000-01-01&quot;), Sort.by(ASC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 3 SQL queries are executed.</p>
<ol>
<li>
<p>Select books and related authors using join as defined in the Entity Graph</p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_0_,
       author2_.id             AS id1_0_1_,
       book0_.isbn             AS isbn2_1_0_,
       book0_.publication_date AS publicat3_1_0_,
       book0_.title            AS title4_1_0_,
       author2_.full_name      AS full_nam2_0_1_,
       authors1_.book_id       AS book_id1_2_0__,
       authors1_.authors_id    AS authors_2_2_0__
FROM   book book0_
       LEFT OUTER JOIN book_authors authors1_
                    ON book0_.id = authors1_.book_id
       LEFT OUTER JOIN author author2_
                    ON authors1_.authors_id = author2_.id
WHERE  book0_.publication_date &gt;? /*2000-01-01*/
ORDER  BY book0_.publication_date ASC  
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
</ol>
<h5><a name="ce895104ae9e9dd02aafbba89a339104"></a>Query method with <code>@EntityGraph</code> and <code>Pageable</code></h5>
<p>Usage of <code>@EntityGraph</code> with <code>Pageable</code> results in warning
<code>HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!</code>.
The whole table is loaded into memory and then filtered.</p>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code></p>
<pre><code class="language-java">@EntityGraph(&quot;Book.authors&quot;)
List&lt;Book&gt; findByPublicationDateAfter(LocalDate date, Pageable pageable);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void entityGraphWithPageable() {
  List&lt;Book&gt; books = bookRepository.findByPublicationDateAfter(
      LocalDate.parse(&quot;2000-01-01&quot;), PageRequest.of(0, 1, ASC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(1)
      .satisfies(equalTo(this.poeaa), atIndex(0));
}
</code></pre>
<p>Query selects 1 book, then the result set is pagination is applied in memory, so 2 SQL queries are executed.</p>
<ol>
<li>
<p>Select books and related authors using join without limiting maximum results (SQL <code>LIMIT</code>)</p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_0_,
       author2_.id             AS id1_0_1_,
       book0_.isbn             AS isbn2_1_0_,
       book0_.publication_date AS publicat3_1_0_,
       book0_.title            AS title4_1_0_,
       author2_.full_name      AS full_nam2_0_1_,
       authors1_.book_id       AS book_id1_2_0__,
       authors1_.authors_id    AS authors_2_2_0__
FROM   book book0_
       LEFT OUTER JOIN book_authors authors1_
                    ON book0_.id = authors1_.book_id
       LEFT OUTER JOIN author author2_
                    ON authors1_.authors_id = author2_.id
WHERE  book0_.publication_date &gt;? /*2000-01-01*/
ORDER  BY book0_.publication_date ASC  
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
</ol>
<h5><a name="260b142dfcc1f303ff3e67de6da4d730"></a>Query method with <code>@EntityGraph</code> with multiple attribute nodes (issue HHH-13740)</h5>
<p>When <code>@EntityGraph</code> has multiple attribute nodes and so defines multiple child collection to be eagerly fetched
we face with issue <a href="https://hibernate.atlassian.net/browse/HHH-13740">HHH-13740</a> related to duplicates in the child collections.</p>
<p>Find out more details about HHH-13740 in the separate <a href="HHH-13740/">examples</a>.</p>
<p><code>com.example.spring.data.jpa.entity.Book</code></p>
<pre><code class="language-java">@NamedEntityGraph(name = &quot;Book.authors-categories&quot;,
    attributeNodes = {
        @NamedAttributeNode(&quot;authors&quot;),
        @NamedAttributeNode(&quot;categories&quot;)
    }
)
</code></pre>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code></p>
<pre><code class="language-java">@EntityGraph(&quot;Book.authors-categories&quot;)
List&lt;Book&gt; findByPublicationDateBetween(LocalDate startDate, LocalDate endDate, Sort sort);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void entityGraphMultipleAttributeNodes() {
  List&lt;Book&gt; books = bookRepository.findByPublicationDateBetween(
      LocalDate.parse(&quot;2000-01-01&quot;), LocalDate.parse(&quot;2020-01-01&quot;),
      Sort.by(ASC, &quot;publicationDate&quot;));
  assertThat(books)
      .containsExactlyInAnyOrder(this.poeaa, this.eip);
  
  assertThat(books.get(0).getAuthors())
      .hasSize(2)
      .containsExactlyInAnyOrder(martinFowler, martinFowler); //duplicate
  assertThat(books.get(1).getAuthors())
      .hasSize(4)
      .containsExactlyInAnyOrder(gregorHohpe, gregorHohpe, bobbyWoolf, bobbyWoolf); //duplicates
}
</code></pre>
<p>1 SQL query is executed.</p>
<ol>
<li>Select books and related authors and categories using SQL join<pre><code class="language-sql">SELECT book0_.id                  AS id1_1_0_,
       author2_.id                AS id1_0_1_,
       category4_.id              AS id1_20_2_,
       book0_.isbn                AS isbn2_1_0_,
       book0_.publication_date    AS publicat3_1_0_,
       book0_.title               AS title4_1_0_,
       author2_.full_name         AS full_nam2_0_1_,
       authors1_.book_id          AS book_id1_2_0__,
       authors1_.authors_id       AS authors_2_2_0__,
       category4_.NAME            AS name2_20_2_,
       categories3_.book_id       AS book_id1_3_1__,
       categories3_.categories_id AS categori2_3_1__
FROM   book book0_
       LEFT OUTER JOIN book_authors authors1_
                    ON book0_.id = authors1_.book_id
       LEFT OUTER JOIN author author2_
                    ON authors1_.authors_id = author2_.id
       LEFT OUTER JOIN book_categories categories3_
                    ON book0_.id = categories3_.book_id
       LEFT OUTER JOIN category category4_
                    ON categories3_.categories_id = category4_.id
WHERE  book0_.publication_date BETWEEN ? AND ? /*2000-01-01,2020-01-01*/
ORDER  BY book0_.publication_date ASC
</code></pre>
</li>
</ol>
<h5><a name="99fac513c058317164ad5a6e20d34f18"></a><code>@Query</code> with JPQL <code>join fetch</code></h5>
<p>One more way to fetch related association using SQL join is to use custom JPQL query with <code>join fetch</code>.
The result set in such a case will contain duplicates if the child collection size is greater than 1 (&gt;=2).
In this example duplicates are caused by join of the book with multiple authors.</p>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code></p>
<pre><code class="language-java">@Query(&quot;select b from Book b join fetch b.authors&quot;
    + &quot; where b.publicationDate &gt; :date&quot;
    + &quot; order by b.publicationDate asc&quot;)
List&lt;Book&gt; findByPublicationDateAfterJoinFetch(LocalDate date);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void jpqlJoinFetch() {
  List&lt;Book&gt; books =
      bookRepository.findByPublicationDateAfterJoinFetch(LocalDate.parse(&quot;2000-01-01&quot;));
  assertThat(books)
      .hasSize(3)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1))
      .satisfies(equalTo(this.eip), atIndex(2)); //duplicate
}
</code></pre>
<p>Query selects 2 books, so 3 SQL queries are executed.</p>
<ol>
<li>
<p>Select books and related authors using join</p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_0_,
       author2_.id             AS id1_0_1_,
       book0_.isbn             AS isbn2_1_0_,
       book0_.publication_date AS publicat3_1_0_,
       book0_.title            AS title4_1_0_,
       author2_.full_name      AS full_nam2_0_1_,
       authors1_.book_id       AS book_id1_2_0__,
       authors1_.authors_id    AS authors_2_2_0__
FROM   book book0_
       INNER JOIN book_authors authors1_
               ON book0_.id = authors1_.book_id
       INNER JOIN author author2_
               ON authors1_.authors_id = author2_.id
WHERE  book0_.publication_date &gt;? /*2000-01-01*/
ORDER  BY book0_.publication_date ASC  
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
</ol>
<h5><a name="ff9705f518ec48b7fa77d2d6cd0c3c14"></a><code>@Query</code> with JPQL <code>join fetch</code> and <code>distinct</code></h5>
<p>A workaround to the issue with duplicates due to using JQPL <code>join fetch</code> is to use <code>distinct</code> operator.</p>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code></p>
<pre><code class="language-java">@Query(&quot;select distinct b from Book b join fetch b.authors&quot;
    + &quot; where b.publicationDate &gt; :date&quot;
    + &quot; order by b.publicationDate asc&quot;)
List&lt;Book&gt; findByPublicationDateAfterJoinFetchDistinct(LocalDate date);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void jpqlJoinFetchDistinct() {
  List&lt;Book&gt; books =
      bookRepository.findByPublicationDateAfterJoinFetchDistinct(LocalDate.parse(&quot;2000-01-01&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 3 SQL queries are executed.</p>
<ol>
<li>
<p>Select distinct books and related authors using join</p>
<pre><code class="language-sql">SELECT DISTINCT book0_.id               AS id1_1_0_,
                author2_.id             AS id1_0_1_,
                book0_.isbn             AS isbn2_1_0_,
                book0_.publication_date AS publicat3_1_0_,
                book0_.title            AS title4_1_0_,
                author2_.full_name      AS full_nam2_0_1_,
                authors1_.book_id       AS book_id1_2_0__,
                authors1_.authors_id    AS authors_2_2_0__
 FROM   book book0_
        INNER JOIN book_authors authors1_
                ON book0_.id = authors1_.book_id
        INNER JOIN author author2_
                ON authors1_.authors_id = author2_.id
 WHERE  book0_.publication_date &gt;? /*2000-01-01*/
 ORDER  BY book0_.publication_date ASC  
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
</ol>
<h5><a name="e11be536b6f6d686f69f20513138cae0"></a>Custom <code>@Repository</code> with Criteria API query</h5>
<p>Spring Data JPA also supports Criteria API queries.
Create an extension interface with a method for a custom query you want to implement using Criteria API.
Extend your repository interface from this extension interface.
Create a class implementing the extension interface and annotate it with <code>@Repository</code>.</p>
<p><code>com.example.spring.data.jpa.repository.BookRepository</code></p>
<pre><code class="language-java">public interface BookRepository
    extends AbstractBookRepository&lt;Book&gt;, BookRepositoryCustom {
/*...*/
}
</code></pre>
<p><code>com.example.spring.data.jpa.repository.BookRepositoryCustom</code></p>
<pre><code class="language-java">public interface BookRepositoryCustom {

  List&lt;Book&gt; findByAuthorNameAndTitle(
      boolean fetchAuthor, boolean distinct, String authorName, String title);
}
</code></pre>
<p><code>com.example.spring.data.jpa.repository.BookRepositoryCustomImpl</code></p>
<pre><code class="language-java">@Repository
@RequiredArgsConstructor
public class BookRepositoryCustomImpl implements BookRepositoryCustom {

  private final EntityManager em;

  @Override
  public List&lt;Book&gt; findByAuthorNameAndTitle(
      boolean fetchAuthor, boolean distinct, String authorName, String title) {

    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery&lt;Book&gt; cq = cb.createQuery(Book.class);

    Root&lt;Book&gt; book = cq.from(Book.class);
    Path&lt;Object&gt; authors;

    if (fetchAuthor) {
      book.fetch(&quot;authors&quot;);
      authors = book.get(&quot;authors&quot;);
    } else {
      authors = book.join(&quot;authors&quot;);
    }

    List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();
    if (authorName != null) {
      predicates.add(cb.like(authors.get(&quot;fullName&quot;), &quot;%&quot; + authorName + &quot;%&quot;));
    }
    if (title != null) {
      predicates.add(cb.like(book.get(&quot;title&quot;), &quot;%&quot; + title + &quot;%&quot;));
    }

    cq.select(book)
        .distinct(distinct)
        .where(predicates.toArray(new Predicate[0]))
        .orderBy(cb.asc(book.get(&quot;publicationDate&quot;)));

    return em.createQuery(cq).getResultList();
  }
}
</code></pre>
<p>In Criteria API to have a predicate referencing child entity you need to use <code>join</code>.
The result set in such a case will contain duplicates if the child collection size is greater than 1 (&gt;=2).
In this example duplicates are caused by join of the book with multiple authors.</p>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void criteriaQuery() {
  log.info(&quot;Custom @Repository with Criteria API query&quot;);

  List&lt;Book&gt; books = bookRepository.findByAuthorNameAndTitle(false, false, null, &quot;Enterprise&quot;);
  assertThat(books)
      .hasSize(3)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1))
      .satisfies(equalTo(this.eip), atIndex(2)); //duplicate
}
</code></pre>
<p><code>FetchType.EAGER</code> doesn't have effect on Criteria API, so all related associations are loaded with a separate SQL query (<code>FetchMode.SELECT</code>).</p>
<p>Query selects 2 books, so 5 SQL queries are executed.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_,
       book0_.isbn             AS isbn2_1_,
       book0_.publication_date AS publicat3_1_,
       book0_.title            AS title4_1_
FROM   book book0_
       INNER JOIN book_authors authors1_
               ON book0_.id = authors1_.book_id
       INNER JOIN author author2_
               ON authors1_.authors_id = author2_.id
WHERE  book0_.title LIKE ? /*%Enterprise%*/
ORDER  BY book0_.publication_date ASC  
</code></pre>
</li>
<li>
<p>Select authors for the 1st book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_id    AS book_id1_2_0_,
       authors0_.authors_id AS authors_2_2_0_,
       author1_.id          AS id1_0_1_,
       author1_.full_name   AS full_nam2_0_1_
FROM   book_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_id = ? /*58*/
</code></pre>
</li>
<li>
<p>Select authors for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_id    AS book_id1_2_0_,
       authors0_.authors_id AS authors_2_2_0_,
       author1_.id          AS id1_0_1_,
       author1_.full_name   AS full_nam2_0_1_
FROM   book_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
</ol>
<h5><a name="1323d64c9e1914e06c3b257f7cea728c"></a>Custom <code>@Repository</code> with Criteria API query with <code>fetch</code></h5>
<p>To eagerly load a related association in Criteria API, use <code>fetch</code> method.</p>
<pre><code class="language-java">CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery&lt;Book&gt; cq = cb.createQuery(Book.class);
Root&lt;Book&gt; book = cq.from(Book.class);
book.fetch(&quot;authors&quot;);
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void criteriaQueryFetch() {
  List&lt;Book&gt; books = bookRepository.findByAuthorNameAndTitle(true, false, null, &quot;Enterprise&quot;);
  assertThat(books)
      .hasSize(3)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1))
      .satisfies(equalTo(this.eip), atIndex(2)); //duplicate
}
</code></pre>
<p>Query selects 2 books, so 3 SQL queries are executed.</p>
<ol>
<li>
<p>Select books and related authors using SQL join</p>
<pre><code class="language-sql">SELECT book0_.id               AS id1_1_0_,
       author2_.id             AS id1_0_1_,
       book0_.isbn             AS isbn2_1_0_,
       book0_.publication_date AS publicat3_1_0_,
       book0_.title            AS title4_1_0_,
       author2_.full_name      AS full_nam2_0_1_,
       authors1_.book_id       AS book_id1_2_0__,
       authors1_.authors_id    AS authors_2_2_0__
FROM   book book0_
       INNER JOIN book_authors authors1_
               ON book0_.id = authors1_.book_id
       INNER JOIN author author2_
               ON authors1_.authors_id = author2_.id
WHERE  book0_.title LIKE ? /*%Enterprise%*/
ORDER  BY book0_.publication_date ASC
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
</ol>
<h5><a name="7285e9899741d937830c2225ff8d01bc"></a>Custom <code>@Repository</code> with Criteria API query with <code>fetch</code> and <code>distinct</code></h5>
<p>A workaround to the issue with duplicates due to using <code>join</code> or <code>fetch</code> in Criteria API is to use <code>distinct</code> method.</p>
<pre><code class="language-java">cq.select(book)
    .distinct(distinct)
    .where(predicates.toArray(new Predicate[0]))
    .orderBy(cb.asc(book.get(&quot;publicationDate&quot;)));
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void criteriaQueryFetchDistinct() {
  List&lt;Book&gt; books = bookRepository.findByAuthorNameAndTitle(true, true, null, &quot;Enterprise&quot;);
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 3 SQL queries are executed.</p>
<ol>
<li>
<p>Select distinct books and related authors using join</p>
<pre><code class="language-sql"> SELECT DISTINCT book0_.id               AS id1_1_0_,
                 author2_.id             AS id1_0_1_,
                 book0_.isbn             AS isbn2_1_0_,
                 book0_.publication_date AS publicat3_1_0_,
                 book0_.title            AS title4_1_0_,
                 author2_.full_name      AS full_nam2_0_1_,
                 authors1_.book_id       AS book_id1_2_0__,
                 authors1_.authors_id    AS authors_2_2_0__
 FROM   book book0_
        INNER JOIN book_authors authors1_
                ON book0_.id = authors1_.book_id
        INNER JOIN author author2_
                ON authors1_.authors_id = author2_.id
 WHERE  book0_.title LIKE ? /*%Enterprise%*/
 ORDER  BY book0_.publication_date ASC  
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*57*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_id       AS book_id1_3_0_,
       categories0_.categories_id AS categori2_3_0_,
       category1_.id              AS id1_20_1_,
       category1_.NAME            AS name2_20_1_
FROM   book_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_id = ? /*58*/
</code></pre>
</li>
</ol>
<h4><a name="239f2f55854878f99d5d4d379a765d39"></a>Entity with <code>@Fetch(JOIN)</code></h4>
<p><code>com.example.spring.data.jpa.entity.BookWithFetchModeJoin</code></p>
<pre><code class="language-java">@Entity
@Data
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
@ToString(callSuper = true)
public class BookWithFetchModeJoin extends AbstractBook {

  @ManyToMany(fetch = EAGER)
  @Fetch(JOIN)
  private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

  @ManyToMany
  @Fetch(JOIN)
  private Set&lt;Category&gt; categories = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<h5><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h5>
<p>When multiple child collection has <code>FetchMode.JOIN</code>
we face with issue <a href="https://hibernate.atlassian.net/browse/HHH-13740">HHH-13740</a> related to duplicates in the child collections.</p>
<p>Find out more details about HHH-13740 in the separate <a href="HHH-13740/">examples</a>.</p>
<p><code>com.example.spring.data.jpa.BookWithFetchModeJoinRepositoryTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  Optional&lt;BookWithFetchModeJoin&gt; poeaa = bookRepository.findById(this.poeaa.getId());
  Optional&lt;BookWithFetchModeJoin&gt; eip = bookRepository.findById(this.eip.getId());

  assertThat(poeaa).hasValueSatisfying(book -&gt;
      assertThat(book.getAuthors())
          .hasSize(2)
          .containsExactlyInAnyOrder(martinFowler, martinFowler)); //duplicate

  assertThat(eip).hasValueSatisfying(book -&gt;
      assertThat(book.getAuthors())
          .hasSize(4)
          .containsExactlyInAnyOrder(gregorHohpe, gregorHohpe, bobbyWoolf, bobbyWoolf)); //duplicates
}
</code></pre>
<p>A single SQL query is executed per <code>CrudRepository.findById</code> call.</p>
<ol>
<li>Select book with authors and categories<pre><code class="language-sql">SELECT bookwithfe0_.id                           AS id1_8_0_,
       bookwithfe0_.isbn                         AS isbn2_8_0_,
       bookwithfe0_.publication_date             AS publicat3_8_0_,
       bookwithfe0_.title                        AS title4_8_0_,
       authors1_.book_with_fetch_mode_join_id    AS book_wit1_9_1_,
       author2_.id                               AS authors_2_9_1_,
       author2_.id                               AS id1_0_2_,
       author2_.full_name                        AS full_nam2_0_2_,
       categories3_.book_with_fetch_mode_join_id AS book_wit1_10_3_,
       category4_.id                             AS categori2_10_3_,
       category4_.id                             AS id1_20_4_,
       category4_.NAME                           AS name2_20_4_
FROM   book_with_fetch_mode_join bookwithfe0_
       LEFT OUTER JOIN book_with_fetch_mode_join_authors authors1_
                    ON bookwithfe0_.id = authors1_.book_with_fetch_mode_join_id
       LEFT OUTER JOIN author author2_
                    ON authors1_.authors_id = author2_.id
       LEFT OUTER JOIN book_with_fetch_mode_join_categories categories3_
                    ON bookwithfe0_.id =
                       categories3_.book_with_fetch_mode_join_id
       LEFT OUTER JOIN category category4_
                    ON categories3_.categories_id = category4_.id
WHERE  bookwithfe0_.id = ?
</code></pre>
</li>
</ol>
<h5><a name="ecfc45d33505baec3249b78ec3e66059"></a>Query method</h5>
<p>The behavior of JQPL queries (query methods) during the loading entities
with associations with <code>FetchMode.JOIN</code> is, at first glance, a bit unexpected.
Instead of loading related collections annotated with <code>@Fetch(JOIN)</code> in the same query
with parent entities using the SQL join operator,
the JPQL query is translated into multiple SQL queries just like with <code>FetchMode.SELECT</code>.
Unlike <code>FetchMode.SELECT</code>, with <code>FetchMode.JOIN</code> the specified <code>FetchType</code> (<code>LAZY</code> and <code>EAGER</code>)
is ignored, and all collections are loaded eagerly.</p>
<p><code>com.example.spring.data.jpa.BookWithFetchModeJoinRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  List&lt;T&gt; books = getBookRepository()
      .findByTitleContains(&quot;Pattern&quot;, PageRequest.of(0, 2, DESC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.eip), atIndex(0))
      .satisfies(equalTo(this.poeaa), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 5 SQL queries are executed.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT bookwithfe0_.id               AS id1_8_,
       bookwithfe0_.isbn             AS isbn2_8_,
       bookwithfe0_.publication_date AS publicat3_8_,
       bookwithfe0_.title            AS title4_8_
FROM   book_with_fetch_mode_join bookwithfe0_
WHERE  bookwithfe0_.title LIKE ? escape ? /*%Pattern%,\*/
ORDER  BY bookwithfe0_.publication_date DESC
LIMIT  ? /*2*/
</code></pre>
</li>
<li>
<p>Select categories for the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_join_id AS book_wit1_10_0_,
       categories0_.categories_id                AS categori2_10_0_,
       category1_.id                             AS id1_20_1_,
       category1_.NAME                           AS name2_20_1_
FROM   book_with_fetch_mode_join_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_join_id = ? /*23*/
</code></pre>
</li>
<li>
<p>Select authors for the 1st book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_join_id AS book_wit1_9_0_,
       authors0_.authors_id                   AS authors_2_9_0_,
       author1_.id                            AS id1_0_1_,
       author1_.full_name                     AS full_nam2_0_1_
FROM   book_with_fetch_mode_join_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_join_id = ? /*23*/
</code></pre>
</li>
<li>
<p>Select categories for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_join_id AS book_wit1_10_0_,
       categories0_.categories_id                AS categori2_10_0_,
       category1_.id                             AS id1_20_1_,
       category1_.NAME                           AS name2_20_1_
FROM   book_with_fetch_mode_join_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_join_id = ? /*24*/
</code></pre>
</li>
<li>
<p>Select authors for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_join_id AS book_wit1_9_0_,
       authors0_.authors_id                   AS authors_2_9_0_,
       author1_.id                            AS id1_0_1_,
       author1_.full_name                     AS full_nam2_0_1_
FROM   book_with_fetch_mode_join_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_join_id = ? /*24*/
</code></pre>
</li>
</ol>
<h4><a name="61d561e02c4002d6d6ad4646e5d328f7"></a>Entity with <code>@Fetch(SELECT)</code></h4>
<p><code>com.example.spring.data.jpa.entity.BookWithFetchModeSelect</code></p>
<pre><code class="language-java">@Entity
@Data
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
@ToString(callSuper = true)
public class BookWithFetchModeSelect extends AbstractBook {

  @ManyToMany(fetch = EAGER)
  @Fetch(SELECT)
  private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

  @ManyToMany
  @Fetch(SELECT)
  private Set&lt;Category&gt; categories = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<p>With <code>FetchMode.SELECT</code> each association for all parent entities from the result set is loaded with a separate SQL <code>SELECT</code>.</p>
<h5><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h5>
<p><code>com.example.spring.data.jpa.BookWithFetchModeSelectRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  Optional&lt;T&gt; poeaa = getBookRepository().findById(this.poeaa.getId());
  assertThat(poeaa).hasValueSatisfying(equalTo(this.poeaa));
}
</code></pre>
<p>3 SQL queries are executed in total.</p>
<ol>
<li>
<p>Select book by ID</p>
<pre><code class="language-sql">SELECT bookwithfe0_.id               AS id1_11_0_,
       bookwithfe0_.isbn             AS isbn2_11_0_,
       bookwithfe0_.publication_date AS publicat3_11_0_,
       bookwithfe0_.title            AS title4_11_0_
FROM   book_with_fetch_mode_select bookwithfe0_
WHERE  bookwithfe0_.id = ? /*69*/
</code></pre>
</li>
<li>
<p>Select authors for the book</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_select_id AS book_wit1_12_0_,
       authors0_.authors_id                     AS authors_2_12_0_,
       author1_.id                              AS id1_0_1_,
       author1_.full_name                       AS full_nam2_0_1_
FROM   book_with_fetch_mode_select_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_select_id = ? /*69*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the book</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_select_id AS book_wit1_13_0_,
       categories0_.categories_id                  AS categori2_13_0_,
       category1_.id                               AS id1_20_1_,
       category1_.NAME                             AS name2_20_1_
FROM   book_with_fetch_mode_select_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_select_id = ? /*69*/
</code></pre>
</li>
</ol>
<h5><a name="ecfc45d33505baec3249b78ec3e66059"></a>Query method</h5>
<p><code>com.example.spring.data.jpa.BookWithFetchModeSelectRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  List&lt;T&gt; books = getBookRepository()
      .findByTitleContains(&quot;Pattern&quot;, PageRequest.of(0, 2, DESC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.eip), atIndex(0))
      .satisfies(equalTo(this.poeaa), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 5 SQL queries are executed.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT bookwithfe0_.id               AS id1_11_,
       bookwithfe0_.isbn             AS isbn2_11_,
       bookwithfe0_.publication_date AS publicat3_11_,
       bookwithfe0_.title            AS title4_11_
FROM   book_with_fetch_mode_select bookwithfe0_
WHERE  bookwithfe0_.title LIKE ? escape ? /*%Pattern%,\*/
ORDER  BY bookwithfe0_.publication_date DESC
LIMIT  ? /*2*/
</code></pre>
</li>
<li>
<p>Select authors for the 1st book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_select_id AS book_wit1_12_0_,
       authors0_.authors_id                     AS authors_2_12_0_,
       author1_.id                              AS id1_0_1_,
       author1_.full_name                       AS full_nam2_0_1_
FROM   book_with_fetch_mode_select_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_select_id = ? /*69*/
</code></pre>
</li>
<li>
<p>Select authors for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_select_id AS book_wit1_12_0_,
       authors0_.authors_id                     AS authors_2_12_0_,
       author1_.id                              AS id1_0_1_,
       author1_.full_name                       AS full_nam2_0_1_
FROM   book_with_fetch_mode_select_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_select_id = ? /*70*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 1st book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_select_id AS book_wit1_13_0_,
       categories0_.categories_id                  AS categori2_13_0_,
       category1_.id                               AS id1_20_1_,
       category1_.NAME                             AS name2_20_1_
FROM   book_with_fetch_mode_select_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_select_id = ? /*70*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_select_id AS book_wit1_13_0_,
       categories0_.categories_id                  AS categori2_13_0_,
       category1_.id                               AS id1_20_1_,
       category1_.NAME                             AS name2_20_1_
FROM   book_with_fetch_mode_select_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_select_id = ? /*69*/
</code></pre>
</li>
</ol>
<h4><a name="76b5b36ea931f6c209971594a5473ffa"></a>Entity with <code>@Fetch(SUBSELECT)</code></h4>
<p><code>com.example.spring.data.jpa.entity.BookWithFetchModeSubselect</code></p>
<pre><code class="language-java">@Entity
@Data
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
@ToString(callSuper = true)
public class BookWithFetchModeSubselect extends AbstractBook {

  @ManyToMany(fetch = EAGER)
  @Fetch(SUBSELECT)
  private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

  @ManyToMany
  @Fetch(SUBSELECT)
  private Set&lt;Category&gt; categories = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<h5><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h5>
<p><code>com.example.spring.data.jpa.BookWithFetchModeSubselectRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  Optional&lt;T&gt; poeaa = getBookRepository().findById(this.poeaa.getId());
  assertThat(poeaa).hasValueSatisfying(equalTo(this.poeaa));
}
</code></pre>
<p><code>FetchMode.SUBSELECT</code> when loading entity by ID doesn't have any sense, so Hibernate ignores it for <code>CrudRepository.findById</code> calls.
Instead, <code>CrudRepository.findById</code> behaves like with <code>FetchMode.SELECT</code>.</p>
<p>3 SQL queries are executed in total.</p>
<ol>
<li>
<p>Select book by ID</p>
<pre><code class="language-sql">SELECT bookwithfe0_.id               AS id1_14_0_,
       bookwithfe0_.isbn             AS isbn2_14_0_,
       bookwithfe0_.publication_date AS publicat3_14_0_,
       bookwithfe0_.title            AS title4_14_0_
FROM   book_with_fetch_mode_subselect bookwithfe0_
WHERE  bookwithfe0_.id = ? /*35*/
</code></pre>
</li>
<li>
<p>Select authors for the book</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_subselect_id AS book_wit1_15_0_,
       authors0_.authors_id                        AS authors_2_15_0_,
       author1_.id                                 AS id1_0_1_,
       author1_.full_name                          AS full_nam2_0_1_
FROM   book_with_fetch_mode_subselect_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_subselect_id = ? /*35*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the book</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_subselect_id AS book_wit1_16_0_,
       categories0_.categories_id                     AS categori2_16_0_,
       category1_.id                                  AS id1_20_1_,
       category1_.NAME                                AS name2_20_1_
FROM   book_with_fetch_mode_subselect_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_subselect_id = ? /*35*/
</code></pre>
</li>
</ol>
<h5><a name="ecfc45d33505baec3249b78ec3e66059"></a>Query method</h5>
<p><code>com.example.spring.data.jpa.BookWithFetchModeSubselectRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  List&lt;T&gt; books = getBookRepository()
      .findByTitleContains(&quot;Pattern&quot;, PageRequest.of(0, 2, DESC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.eip), atIndex(0))
      .satisfies(equalTo(this.poeaa), atIndex(1));
}
</code></pre>
<p><code>FetchMode.SUBSELECT</code> loads child collections for all parent entities with a single SQL query with sub-select,
solving &quot;N+1 selects&quot; problem.
But <code>FetchMode.SUBSELECT</code> ignores pagination (<code>LIMIT</code>) in the sub-select what may lead to loading the whole database table into memory.</p>
<p>3 SQL queries are executed regardless of the result set size.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT bookwithfe0_.id               AS id1_14_,
       bookwithfe0_.isbn             AS isbn2_14_,
       bookwithfe0_.publication_date AS publicat3_14_,
       bookwithfe0_.title            AS title4_14_
FROM   book_with_fetch_mode_subselect bookwithfe0_
WHERE  bookwithfe0_.title LIKE ? escape ? /*%Pattern%,\*/
ORDER  BY bookwithfe0_.publication_date DESC
LIMIT  ? /*2*/
</code></pre>
</li>
<li>
<p>Select authors for all selected books</p>
<pre><code class="language-sql">SELECT authors0_.book_with_fetch_mode_subselect_id AS book_wit1_15_1_,
       authors0_.authors_id                        AS authors_2_15_1_,
       author1_.id                                 AS id1_0_0_,
       author1_.full_name                          AS full_nam2_0_0_
FROM   book_with_fetch_mode_subselect_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_fetch_mode_subselect_id IN (SELECT bookwithfe0_.id
                                                       FROM   book_with_fetch_mode_subselect bookwithfe0_
                                                       WHERE  bookwithfe0_.title LIKE ? ESCAPE ?) /*%Pattern%,\*/
</code></pre>
</li>
<li>
<p>Lazily select categories for all selected books after the first access to categories collection of any entity from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_with_fetch_mode_subselect_id AS book_wit1_16_1_,
       categories0_.categories_id                     AS categori2_16_1_,
       category1_.id                                  AS id1_20_0_,
       category1_.NAME                                AS name2_20_0_
FROM   book_with_fetch_mode_subselect_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_fetch_mode_subselect_id IN (SELECT bookwithfe0_.id
                                                          FROM   book_with_fetch_mode_subselect bookwithfe0_
                                                          WHERE  bookwithfe0_.title LIKE ? ESCAPE ?) /*%Pattern%,\*/
</code></pre>
</li>
</ol>
<h4><a name="b77feec501b1fe41ebee44d25e206880"></a>Entity with <code>@BatchSize</code></h4>
<p><code>com.example.spring.data.jpa.entity.BookWithBatchSize</code></p>
<pre><code class="language-java">@Entity
@Data
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
@ToString(callSuper = true)
public class BookWithBatchSize extends AbstractBook {

  @ManyToMany(fetch = EAGER)
  @BatchSize(size = 2)
  private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

  @ManyToMany
  @BatchSize(size = 2)
  private Set&lt;Category&gt; categories = new LinkedHashSet&lt;&gt;();
}
</code></pre>
<h5><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h5>
<p><code>com.example.spring.data.jpa.BookWithBatchSizeRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  Optional&lt;T&gt; poeaa = getBookRepository().findById(this.poeaa.getId());
  assertThat(poeaa).hasValueSatisfying(equalTo(this.poeaa));
}
</code></pre>
<p><code>@BatchSize</code> doesn't influence loading entity by ID, so Hibernate ignores it for <code>CrudRepository.findById</code> calls.
So, <code>CrudRepository.findById</code> behaves like without explicitly defined <code>FetchMode</code> with <code>@Fetch</code>.</p>
<p>2 SQL queries are executed in total.</p>
<ol>
<li>
<p>Select book with authors by ID using SQL join</p>
<pre><code class="language-sql">SELECT bookwithba0_.id                   AS id1_5_0_,
       bookwithba0_.isbn                 AS isbn2_5_0_,
       bookwithba0_.publication_date     AS publicat3_5_0_,
       bookwithba0_.title                AS title4_5_0_,
       authors1_.book_with_batch_size_id AS book_wit1_6_1_,
       author2_.id                       AS authors_2_6_1_,
       author2_.id                       AS id1_0_2_,
       author2_.full_name                AS full_nam2_0_2_
FROM   book_with_batch_size bookwithba0_
       LEFT OUTER JOIN book_with_batch_size_authors authors1_
                    ON bookwithba0_.id = authors1_.book_with_batch_size_id
       LEFT OUTER JOIN author author2_
                    ON authors1_.authors_id = author2_.id
WHERE  bookwithba0_.id = ? /*11*/
</code></pre>
</li>
<li>
<p>Lazily select categories after the first access to the book</p>
<pre><code class="language-sql">SELECT categories0_.book_with_batch_size_id AS book_wit1_7_1_,
       categories0_.categories_id           AS categori2_7_1_,
       category1_.id                        AS id1_20_0_,
       category1_.NAME                      AS name2_20_0_
FROM   book_with_batch_size_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_batch_size_id = ? /*11*/
</code></pre>
</li>
</ol>
<h5><a name="ecfc45d33505baec3249b78ec3e66059"></a>Query method</h5>
<p><code>com.example.spring.data.jpa.BookWithBatchSizeRepositoryTest</code> extends <code>com.example.spring.data.jpa.AbstractBookRepositoryBaseTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  List&lt;T&gt; books = getBookRepository()
      .findByTitleContains(&quot;Pattern&quot;, PageRequest.of(0, 2, DESC, &quot;publicationDate&quot;));
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.eip), atIndex(0))
      .satisfies(equalTo(this.poeaa), atIndex(1));
}
</code></pre>
<p>With <code>@BatchSize(size = batchSize)</code> Hibernate generates (1 + ceil(N / batchSize)).</p>
<p>Query selects 2 books, so 3 SQL queries are executed.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT bookwithba0_.id               AS id1_5_,
       bookwithba0_.isbn             AS isbn2_5_,
       bookwithba0_.publication_date AS publicat3_5_,
       bookwithba0_.title            AS title4_5_
FROM   book_with_batch_size bookwithba0_
WHERE  bookwithba0_.title LIKE ? escape ? /*%Pattern%,\*/
ORDER  BY bookwithba0_.publication_date DESC
LIMIT  ? /*2*/
</code></pre>
</li>
<li>
<p>Select authors for 2 selected books using SQL <code>IN</code> operator</p>
<pre><code class="language-sql">SELECT authors0_.book_with_batch_size_id AS book_wit1_6_1_,
       authors0_.authors_id              AS authors_2_6_1_,
       author1_.id                       AS id1_0_0_,
       author1_.full_name                AS full_nam2_0_0_
FROM   book_with_batch_size_authors authors0_
       INNER JOIN author author1_
               ON authors0_.authors_id = author1_.id
WHERE  authors0_.book_with_batch_size_id IN ( ?, ? ) /*11,12*/
</code></pre>
</li>
<li>
<p>Lazily select categories for 2 selected books after the first access to categories collection of any entity from the result set</p>
<pre><code class="language-sql">SELECT categories0_.book_with_batch_size_id AS book_wit1_7_1_,
       categories0_.categories_id           AS categori2_7_1_,
       category1_.id                        AS id1_20_0_,
       category1_.NAME                      AS name2_20_0_
FROM   book_with_batch_size_categories categories0_
       INNER JOIN category category1_
               ON categories0_.categories_id = category1_.id
WHERE  categories0_.book_with_batch_size_id IN ( ?, ? ) /*12,11*/
</code></pre>
</li>
</ol>
<h4><a name="1049387d75c060dc77f67c5477fb48d4"></a>Entity with multiple bags resulting in <code>MultipleBagFetchException</code></h4>
<p>Entity with multiple bags (two <code>@ManyToMany</code> collections with type <code>List</code>) resulting in <code>MultipleBagFetchException</code></p>
<p><code>com.example.spring.data.jpa.entity.BookWithMultipleBags</code></p>
<pre><code class="language-java">@Entity
@NamedEntityGraph(name = &quot;BookWithMultipleBags.authors-categories&quot;,
    attributeNodes = {
        @NamedAttributeNode(&quot;authors&quot;),
        @NamedAttributeNode(&quot;categories&quot;)
    }
)
@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BookWithMultipleBags {

  @Id
  @GeneratedValue
  private Long id;

  @NaturalId
  @EqualsAndHashCode.Include
  private String isbn;

  private String title;

  private LocalDate publicationDate;

  @ManyToMany(fetch = EAGER)
  private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

  @ManyToMany
  private List&lt;Category&gt; categories = new ArrayList&lt;&gt;();
}
</code></pre>
<p>Instead of <code>Set&lt;Category&gt;</code> like in <code>AbstractBook</code> and its children
<code>BookWithMultipleBags</code> has <code>List&lt;Category&gt;</code>.
Multiple many-to-many relations of type List with <code>FetchMode.JOIN</code> leads to
<code>MultipleBagFetchException: cannot simultaneously fetch multiple bags</code>.</p>
<p><code>com.example.spring.data.jpa.BookWithMultipleBagsRepositoryTest</code></p>
<pre><code class="language-java">@Test
void multipleBagFetchException() {
  assertThatThrownBy(() -&gt; bookRepository.findByPublicationDateBetween(
      LocalDate.parse(&quot;2000-01-01&quot;), LocalDate.parse(&quot;2020-01-01&quot;),
      Sort.by(ASC, &quot;publicationDate&quot;)))
      .hasRootCauseInstanceOf(MultipleBagFetchException.class)
      .hasMessageContaining(&quot;cannot simultaneously fetch multiple bags&quot;);
}
</code></pre>
<p>Trying to fetch multiple many-to-many relations that both have type List results in exception
(<code>List&lt;Author&gt; authors</code> and <code>List&lt;Category&gt; categories</code>) an exception
<code>org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags</code> is thrown.</p>
<h3><a name="9a3347442ef97064c198bda69c16f816"></a>Locking strategies</h3>
<p><code>com.example.spring.data.jpa.entity.BookRating</code></p>
<pre><code class="language-java">@Entity
@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BookRating {

  @Id
  @GeneratedValue
  private Long id;

  @Version
  private int version;

  @OneToOne(fetch = LAZY)
  @JoinColumn(unique = true)
  @EqualsAndHashCode.Include
  private Book book;

  private BigDecimal rating;

  private int numberOfRatings;
}
</code></pre>
<h4><a name="272ede57357a5f214f2904c15e3fe103"></a>Implicit optimistic lock of entity with <code>@Version</code> on modification</h4>
<p><code>com.example.spring.data.jpa.repository.BookRatingRepository</code></p>
<pre><code class="language-java">BookRating findByBookIsbn(String isbn);
</code></pre>
<p>If an entity has a field annotated with <code>@Version</code>, optimistic locking is enabled by default if the entity was modified, even without explicitly specifying <code>LockModeType</code>.
But if the entity was not modified, there will be no version check before transaction commit.</p>
<p><code>com.example.spring.data.jpa.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">@Test
void implicitOptimisticLock() {
  assertThatThrownBy(() -&gt;
      doInNewTransaction(() -&gt; {
        BookRating ratingTx1 = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

        doInNewTransaction(() -&gt; {
          BookRating ratingTx2 = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

          assertThat(ratingTx2.getVersion()).isEqualTo(this.rating.getVersion());

          ratingTx2.setRating(ratingTx2.getRating().add(new BigDecimal(&quot;0.1&quot;)));
          ratingTx2.setNumberOfRatings(ratingTx2.getNumberOfRatings() + 1);
        });

        assertThat(ratingTx1.getVersion()).isEqualTo(this.rating.getVersion());

        ratingTx1.setRating(ratingTx1.getRating().add(new BigDecimal(&quot;0.2&quot;)));
        ratingTx1.setNumberOfRatings(ratingTx1.getNumberOfRatings() + 1);
      }))
      .isInstanceOf(ObjectOptimisticLockingFailureException.class)
      .hasCauseInstanceOf(StaleObjectStateException.class);

  BookRating rating = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

  assertThat(rating.getVersion()).isEqualTo(this.rating.getVersion() + 1);
  assertThat(rating.getRating())
      .isEqualByComparingTo(this.rating.getRating().add(new BigDecimal(&quot;0.1&quot;)));
  assertThat(rating.getNumberOfRatings()).isEqualTo(this.rating.getNumberOfRatings() + 1);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Creating new transaction #1</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       LEFT OUTER JOIN book book1_
                    ON bookrating0_.book_id = book1_.id
WHERE  book1_.isbn = ? /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Suspending current transaction #1, creating new transaction #2</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       LEFT OUTER JOIN book book1_
                    ON bookrating0_.book_id = book1_.id
WHERE  book1_.isbn = ? /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Initiating transaction #2 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    book_id = ?, /*9*/
       number_of_ratings = ?, /*241*/
       rating = ?, /*4.50*/
       version = ? /*1*/
WHERE  id = ? /*10*/
       AND version = ? /*0*/
</code></pre>
</li>
<li>
<p>Resuming suspended transaction #1 after completion of inner transaction #2</p>
</li>
<li>
<p>Initiating transaction #1 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    book_id = ?, /*9*/
       number_of_ratings = ?, /*241*/
       rating = ?, /*4.60*/
       version = ? /*1*/
WHERE  id = ? /*10*/
       AND version = ? /*0*/
</code></pre>
</li>
<li>
<p>Optimistic locking failed; nested exception is <code>org.hibernate.StaleObjectStateException</code> Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect)</p>
</li>
<li>
<p>Initiating transaction #1 rollback after commit exception</p>
</li>
</ol>
<h4><a name="502c2256dbc0a223143500d9f9b3b5cc"></a>Explicit optimistic lock <code>@Lock(OPTIMISTIC)</code></h4>
<p><code>com.example.spring.data.jpa.repository.BookRatingRepository</code></p>
<pre><code class="language-java">@Lock(OPTIMISTIC)
@Query(&quot;select br from BookRating br where br.book.isbn = :isbn&quot;)
BookRating findByBookIsbnOptimisticLock(String isbn);
</code></pre>
<p>When <code>LockModeType.OPTIMISTIC</code> is used, if an entity was not modified,
and a version check can't be done in an <code>UPDATE</code>,
it is still done before a transaction commit using a simple <code>SELECT version FROM tbl</code>.
Note that between <code>SELECT</code> doing version check, and a commit of the current transaction there is a small time gap.
There is a risk that during this time another transaction still can change this entity.</p>
<p><code>com.example.spring.data.jpa.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">@Test
void explicitOptimisticLock() {
  assertThatThrownBy(() -&gt;
      doInNewTransaction(() -&gt; {
        BookRating ratingTx1 =
            bookRatingRepository.findByBookIsbnOptimisticLock(this.book.getIsbn());

        doInNewTransaction(() -&gt; {
          BookRating ratingTx2 = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

          assertThat(ratingTx2.getVersion()).isEqualTo(this.rating.getVersion());

          ratingTx2.setRating(ratingTx2.getRating().add(new BigDecimal(&quot;0.1&quot;)));
          ratingTx2.setNumberOfRatings(ratingTx2.getNumberOfRatings() + 1);
        });

        assertThat(ratingTx1.getVersion()).isEqualTo(this.rating.getVersion());
      }))
      .isInstanceOf(ObjectOptimisticLockingFailureException.class)
      .hasCauseInstanceOf(OptimisticLockException.class);

  BookRating rating = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

  assertThat(rating.getVersion()).isEqualTo(this.rating.getVersion() + 1);
  assertThat(rating.getRating())
      .isEqualByComparingTo(this.rating.getRating().add(new BigDecimal(&quot;0.1&quot;)));
  assertThat(rating.getNumberOfRatings()).isEqualTo(this.rating.getNumberOfRatings() + 1);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Creating new transaction #1</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       LEFT OUTER JOIN book book1_
                    ON bookrating0_.book_id = book1_.id
WHERE  book1_.isbn = ? /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Suspending current transaction #1, creating new transaction #2</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       LEFT OUTER JOIN book book1_
                    ON bookrating0_.book_id = book1_.id
WHERE  book1_.isbn = ? /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Initiating transaction #2 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    book_id = ?, /*9*/
       number_of_ratings = ?, /*241*/
       rating = ?, /*4.50*/
       version = ? /*1*/
WHERE  id = ? /*6*/
       AND version = ? /*0*/
</code></pre>
</li>
<li>
<p>Resuming suspended transaction #1 after completion of inner transaction #2</p>
</li>
<li>
<p>Initiating transaction #1 commit</p>
<pre><code class="language-sql">SELECT version
FROM   book_rating
WHERE  id = ? /*6*/
</code></pre>
</li>
<li>
<p>Optimistic locking failed; nested exception is <code>org.hibernate.OptimisticLockException</code></p>
</li>
<li>
<p>Initiating transaction #1 rollback after commit exception</p>
</li>
</ol>
<h4><a name="6efaef54090120ae008692898745a547"></a>Explicit optimistic lock <code>@Lock(OPTIMISTIC_FORCE_INCREMENT)</code></h4>
<p><code>com.example.spring.data.jpa.repository.BookRatingRepository</code></p>
<pre><code class="language-java">@Lock(OPTIMISTIC_FORCE_INCREMENT)
@Query(&quot;select br from BookRating br where br.book.isbn = :isbn&quot;)
BookRating findByBookIsbnOptimisticForceIncrementLock(String isbn);
</code></pre>
<p>When <code>LockModeType.OPTIMISTIC_FORCE_INCREMENT</code> is used,
a version is incremented using an <code>UPDATE tlb SET version = version + 1</code> even if an entity was not modified.</p>
<p><code>com.example.spring.data.jpa.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">@Test
void explicitOptimisticForceIncrementLock() {
  assertThatThrownBy(() -&gt;
      doInNewTransaction(() -&gt; {
        BookRating ratingTx1 =
            bookRatingRepository.findByBookIsbnOptimisticForceIncrementLock(this.book.getIsbn());

        doInNewTransaction(() -&gt; {
          BookRating ratingTx2 = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

          assertThat(ratingTx2.getVersion()).isEqualTo(this.rating.getVersion());

          ratingTx2.setRating(ratingTx2.getRating().add(new BigDecimal(&quot;0.1&quot;)));
          ratingTx2.setNumberOfRatings(ratingTx2.getNumberOfRatings() + 1);
        });

        assertThat(ratingTx1.getVersion()).isEqualTo(this.rating.getVersion());
      }))
      .isInstanceOf(ObjectOptimisticLockingFailureException.class)
      .hasCauseInstanceOf(StaleObjectStateException.class);

  BookRating rating = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

  assertThat(rating.getVersion()).isEqualTo(this.rating.getVersion() + 1);
  assertThat(rating.getRating())
      .isEqualByComparingTo(this.rating.getRating().add(new BigDecimal(&quot;0.1&quot;)));
  assertThat(rating.getNumberOfRatings()).isEqualTo(this.rating.getNumberOfRatings() + 1);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Creating new transaction #1</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       LEFT OUTER JOIN book book1_
                    ON bookrating0_.book_id = book1_.id
WHERE  book1_.isbn = ? /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Suspending current transaction #1, creating new transaction #2</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       LEFT OUTER JOIN book book1_
                    ON bookrating0_.book_id = book1_.id
WHERE  book1_.isbn = ? /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Initiating transaction #2 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    book_id = ?, /*9*/
       number_of_ratings = ?, /*241*/
       rating = ?, /*4.50*/
       version = ? /*1*/
WHERE  id = ? /*4*/
       AND version = ? /*0*/
</code></pre>
</li>
<li>
<p>Resuming suspended transaction #1 after completion of inner transaction #2</p>
</li>
<li>
<p>Initiating transaction #1 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    version = ? /*1*/
WHERE  id = ? /*4*/
       AND version = ? /*0*/
</code></pre>
</li>
<li>
<p>Optimistic locking failed; nested exception is <code>org.hibernate.StaleObjectStateException</code> Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect)</p>
</li>
<li>
<p>Initiating transaction #1 rollback after commit exception</p>
</li>
</ol>
<h4><a name="c2b4e4a7c69f6c6b216e05a547731c57"></a>Explicit pessimistic write lock <code>@Lock(PESSIMISTIC_WRITE)</code></h4>
<p><code>com.example.spring.data.jpa.repository.BookRatingRepository</code></p>
<pre><code class="language-java">@Lock(PESSIMISTIC_WRITE)
@Query(&quot;select br from BookRating br where br.book.isbn = :isbn&quot;)
BookRating findByBookIsbnPessimisticWriteLock(String isbn);
</code></pre>
<p>When <code>LockModeType.PESSIMISTIC_WRITE</code> is used, a record is locked using a <code>SELECT FOR UPDATE</code>.</p>
<p><code>com.example.spring.data.jpa.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">@Test
void explicitPessimisticWriteLock() {
  CountDownLatch startLatch = new CountDownLatch(1);
  CountDownLatch doneLatch = new CountDownLatch(2);

  doInNewTransaction(() -&gt; {
    BookRating ratingTx1 =
        bookRatingRepository.findByBookIsbnPessimisticWriteLock(this.book.getIsbn());

    CompletableFuture.runAsync(() -&gt;
        doInNewTransaction(() -&gt; {
          startLatch.countDown();

          BookRating ratingTx2 =
              bookRatingRepository.findByBookIsbnPessimisticWriteLock(this.book.getIsbn());

          assertThat(ratingTx2.getVersion()).isEqualTo(this.rating.getVersion() + 1);

          ratingTx2.setRating(ratingTx2.getRating().add(new BigDecimal(&quot;0.1&quot;)));
          ratingTx2.setNumberOfRatings(ratingTx2.getNumberOfRatings() + 1);
        }, doneLatch));

    await(startLatch);

    assertThat(ratingTx1.getVersion()).isEqualTo(this.rating.getVersion());

    ratingTx1.setRating(ratingTx1.getRating().add(new BigDecimal(&quot;0.2&quot;)));
    ratingTx1.setNumberOfRatings(ratingTx1.getNumberOfRatings() + 1);
  }, doneLatch);

  await(doneLatch);

  BookRating rating = bookRatingRepository.findByBookIsbn(this.book.getIsbn());

  assertThat(rating.getVersion()).isEqualTo(this.rating.getVersion() + 2);
  assertThat(rating.getRating())
      .isEqualByComparingTo(this.rating.getRating().add(new BigDecimal(&quot;0.3&quot;)));
  assertThat(rating.getNumberOfRatings()).isEqualTo(this.rating.getNumberOfRatings() + 2);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Creating new transaction #1</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       CROSS JOIN book book1_
WHERE  bookrating0_.book_id = book1_.id
       AND book1_.isbn = ? /*007-6092019909*/
FOR UPDATE OF bookrating0_
</code></pre>
</li>
<li>
<p>Initiating transaction #1 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    book_id = ?, /*7*/
       number_of_ratings = ?, /*241*/
       rating = ?, /*4.60*/
       version = ? /*1*/
WHERE  id = ? /*8*/
       AND version = ? /*0*/ 
</code></pre>
</li>
<li>
<p>Creating new transaction #2</p>
<pre><code class="language-sql">SELECT bookrating0_.id                AS id1_4_,
       bookrating0_.book_id           AS book_id5_4_,
       bookrating0_.number_of_ratings AS number_o2_4_,
       bookrating0_.rating            AS rating3_4_,
       bookrating0_.version           AS version4_4_
FROM   book_rating bookrating0_
       CROSS JOIN book book1_
WHERE  bookrating0_.book_id = book1_.id
       AND book1_.isbn = ? /*007-6092019909*/
FOR UPDATE OF bookrating0_
</code></pre>
</li>
<li>
<p>Initiating transaction #2 commit</p>
<pre><code class="language-sql">UPDATE book_rating
SET    book_id = ?, /*7*/
       number_of_ratings = ?, /*242*/
       rating = ?, /*4.70*/
       version = ? /*2*/
WHERE  id = ? /*8*/
       AND version = ? /*1*/
</code></pre>
</li>
</ol>
<h4><a name="657a4b524b13a122706ee27f7675bcf7"></a>Explicit pessimistic read lock <code>@Lock(PESSIMISTIC_READ)</code></h4>
<p><code>com.example.spring.data.jpa.repository.BookRatingRepository</code></p>
<pre><code class="language-java">@Lock(PESSIMISTIC_READ)
@Query(&quot;select br from BookRating br where br.book.isbn = :isbn&quot;)
BookRating findByBookIsbnPessimisticReadLock(String isbn);
</code></pre>
<p>When <code>LockModeType.PESSIMISTIC_READ</code> is used, a record is locked using an <code>SELECT FOR SHARE</code> in PostgreSQL
and <code>SELECT FOR UPDATE</code> in databases without shared row-level locks.</p>
<p><code>com.example.spring.data.jpa.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">@Test
void explicitPessimisticReadLock() {
  CountDownLatch startLatch = new CountDownLatch(1);
  CountDownLatch doneLatch = new CountDownLatch(3);

  doInNewTransaction(() -&gt; {
    bookRatingRepository.findByBookIsbnPessimisticReadLock(this.book.getIsbn());

    doInNewTransaction(() -&gt;
            bookRatingRepository.findByBookIsbnPessimisticReadLock(this.book.getIsbn()),
        doneLatch);

    CompletableFuture.runAsync(() -&gt;
        doInNewTransaction(() -&gt; {
          startLatch.countDown();

          bookRatingRepository.findByBookIsbnPessimisticWriteLock(this.book.getIsbn());
        }, doneLatch));

    await(startLatch);
  }, doneLatch);

  await(doneLatch);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Creating new transaction #1</p>
<pre><code class="language-sql">SELECT     bookrating0_.id                AS id1_4_,
           bookrating0_.book_id           AS book_id5_4_,
           bookrating0_.number_of_ratings AS number_o2_4_,
           bookrating0_.rating            AS rating3_4_,
           bookrating0_.version           AS version4_4_
FROM       book_rating bookrating0_
CROSS JOIN book book1_
WHERE      bookrating0_.book_id=book1_.id
AND        book1_.isbn=? FOR share OF bookrating0_ /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Suspending current transaction, creating new transaction #2</p>
<pre><code class="language-sql">SELECT     bookrating0_.id                AS id1_4_,
           bookrating0_.book_id           AS book_id5_4_,
           bookrating0_.number_of_ratings AS number_o2_4_,
           bookrating0_.rating            AS rating3_4_,
           bookrating0_.version           AS version4_4_
FROM       book_rating bookrating0_
CROSS JOIN book book1_
WHERE      bookrating0_.book_id=book1_.id
AND        book1_.isbn=? FOR share OF bookrating0_ /*007-6092019909*/
</code></pre>
</li>
<li>
<p>Initiating transaction #1 commit</p>
</li>
<li>
<p>Initiating transaction #2 commit</p>
</li>
</ol>
<h3><a name="532d5a8c2809912b992aa517d1e46ced"></a>Mapping from entity to DTO using MapStruct</h3>
<p><code>com.example.spring.data.jpa.dto.BookDto</code></p>
<pre><code class="language-java">@Data
public class BookDto {

  private String isbn;
  private String title;
  private LocalDate publicationDate;
  private List&lt;AuthorDto&gt; authors = new ArrayList&lt;&gt;();
  private List&lt;CategoryDto&gt; categories = new ArrayList&lt;&gt;();
}
</code></pre>
<p><code>com.example.spring.data.jpa.mapper.BookMapper</code></p>
<pre><code class="language-java">@Mapper(componentModel = &quot;spring&quot;)
public interface BookMapper {

  BookDto toBookDto(Book book);

  @Mapping(source = &quot;fullName&quot;, target = &quot;name&quot;)
  AuthorDto toAuthorDtos(Author author);

  @Mapping(source = &quot;name&quot;, target = &quot;label&quot;)
  CategoryDto toCategoryDto(Category category);
}
</code></pre>
<p><code>com.example.spring.data.jpa.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void mapToDto() {
  log.info(&quot;Mapping from entity to DTO using MapStruct&quot;);

  Optional&lt;BookDto&gt; eip = bookRepository.findById(this.eip.getId())
      .map(bookMapper::toBookDto);
  assertThat(eip).hasValueSatisfying(book -&gt; {
    assertThat(book.getIsbn()).isNotEmpty();
    assertThat(book.getTitle()).isNotEmpty();
    assertThat(book.getPublicationDate()).isNotNull();
    assertThat(book.getAuthors()).hasSize(2);
    assertThat(book.getCategories()).hasSize(2);
    log.info(&quot;{}&quot;, book);
  });
}
</code></pre>
<h2><a name="1ef62fd469285970a640c75be1cbdb9a"></a>Spring Data JDBC example</h2>
<p><a href="spring-data-jdbc-examples/">spring-data-jdbc-examples</a> has the same domain (book, author, category, rating) like Spring Data JPA example.</p>
<p>In the example there are 3 Aggregates:</p>
<ol>
<li><code>Book</code> (Aggregate Root), <code>BookAuthor</code>, <code>BookCategory</code></li>
<li><code>Author</code> (Aggregate Root)</li>
<li><code>Category</code> (Aggregate Root)</li>
</ol>
<p><strong>UML class diagram</strong></p>
<p><img src="spring-data-jdbc-examples/img/classes.png" alt="Actual UML class diagram"></p>
<p><strong>Entity-relationship diagram</strong></p>
<p><img src="spring-data-jdbc-examples/img/tables.png" alt="Entity-relationship diagram"></p>
<h3><a name="ca1ea02c10b7c37f425b9b7dd86d5e11"></a>Test data</h3>
<pre><code class="language-java">void saveCategories() {
  softwareDevelopment = Category.of(&quot;Software development&quot;);
  softwareDevelopment = categoryRepository.save(softwareDevelopment);

  systemDesign = Category.of(&quot;System design&quot;);
  systemDesign = categoryRepository.save(systemDesign);
}

void saveAuthors() {
  martinFowler = Author.of(&quot;Martin Fowler&quot;);
  martinFowler = authorRepository.save(martinFowler);

  gregorHohpe = Author.of(&quot;Gregor Hohpe&quot;);
  gregorHohpe = authorRepository.save(gregorHohpe);

  bobbyWoolf = Author.of(&quot;Bobby Woolf&quot;);
  bobbyWoolf = authorRepository.save(bobbyWoolf);
}

void saveBooks() {
  poeaa = Book.of(&quot;007-6092019909&quot;,
      &quot;Patterns of Enterprise Application Architecture&quot;,
      LocalDate.parse(&quot;2002-11-15&quot;));
  poeaa.addAuthor(martinFowler);
  poeaa.addCategory(softwareDevelopment);
  poeaa.addCategory(systemDesign);
  poeaa = bookRepository.save(poeaa);

  eip = Book.of(&quot;978-0321200686&quot;,
      &quot;Enterprise Integration Patterns&quot;, LocalDate.parse(&quot;2003-10-20&quot;));
  eip.addAuthor(gregorHohpe);
  eip.addAuthor(bobbyWoolf);
  eip.addCategory(softwareDevelopment);
  eip.addCategory(systemDesign);
  eip = bookRepository.save(eip);
}
</code></pre>
<h3><a name="cf43137803fb51915f84cbc5c3068d34"></a>Queries</h3>
<pre><code class="language-java">@Data
@AllArgsConstructor
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public final class Book {

  @Id
  @With
  private final Long id;

  @EqualsAndHashCode.Include
  private final String isbn;

  private final String title;

  private final LocalDate publicationDate;

  private final List&lt;BookAuthor&gt; authors;

  private final Set&lt;BookCategory&gt; categories;

  public static Book of(String isbn, String title, LocalDate publicationDate) {
    return new Book(null, isbn, title, publicationDate, new ArrayList&lt;&gt;(), new HashSet&lt;&gt;());
  }

  public void addAuthor(Author author) {
    authors.add(new BookAuthor(author.getId()));
  }

  public void addCategory(Category category) {
    categories.add(new BookCategory(category.getId()));
  }
}
</code></pre>
<h4><a name="07109b7f3df585c23975718b13843dac"></a><code>CrudRepository.save</code></h4>
<p>During saving all entities referenced from an aggregate root are deleted and recreated.</p>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void updateOneToManyRelations() {
  Book eip = bookRepository.findById(this.eip.getId()).get();
  eip.getAuthors().remove(1);
  eip = bookRepository.save(eip);

  eip.getCategories().removeIf(categoryRef -&gt;
      Objects.equals(categoryRef.getCategory(), systemDesign.getId()));
  eip = bookRepository.save(eip);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Find by book ID</p>
<pre><code class="language-sql">SELECT &quot;book&quot;.&quot;id&quot;               AS &quot;id&quot;,
       &quot;book&quot;.&quot;isbn&quot;             AS &quot;isbn&quot;,
       &quot;book&quot;.&quot;title&quot;            AS &quot;title&quot;,
       &quot;book&quot;.&quot;publication_date&quot; AS &quot;publication_date&quot;
FROM   &quot;book&quot;
WHERE  &quot;book&quot;.&quot;id&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">SELECT &quot;book_author&quot;.&quot;author&quot;   AS &quot;author&quot;,
       &quot;book_author&quot;.&quot;book_key&quot; AS &quot;book_key&quot;
FROM   &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*2*/
ORDER  BY &quot;book_key&quot;
</code></pre>
<pre><code class="language-sql">SELECT &quot;book_category&quot;.&quot;category&quot; AS &quot;category&quot;
FROM   &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
</li>
<li>
<p>Remove one book author and save book</p>
<pre><code class="language-sql">UPDATE &quot;book&quot;
SET    &quot;isbn&quot; = ?, /*978-0321200686*/
       &quot;title&quot; = ?, /*Enterprise Integration Patterns*/
       &quot;publication_date&quot; = ? /*2003-10-20 00:00:00.0*/
WHERE  &quot;book&quot;.&quot;id&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">DELETE FROM &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">DELETE FROM &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">INSERT INTO &quot;book_author&quot;
            (&quot;author&quot;,
              &quot;book&quot;,
              &quot;book_key&quot;)
VALUES      (?, /*2*/
              ?, /*2*/
              ?) /*0*/
</code></pre>
<pre><code class="language-sql">INSERT INTO &quot;book_category&quot;
            (&quot;book&quot;,
              &quot;category&quot;)
VALUES      (?, /*2*/
              ?) /*1*/
</code></pre>
<pre><code class="language-sql">INSERT INTO &quot;book_category&quot;
            (&quot;book&quot;,
              &quot;category&quot;)
VALUES      (?, /*2*/
              ?) /*2*/
</code></pre>
</li>
<li>
<p>Remove one book category and save book</p>
<pre><code class="language-sql">UPDATE &quot;book&quot;
SET    &quot;isbn&quot; = ?, /*978-0321200686*/
       &quot;title&quot; = ?, /*Enterprise Integration Patterns*/
       &quot;publication_date&quot; = ? /*2003-10-20 00:00:00.0*/
WHERE  &quot;book&quot;.&quot;id&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">DELETE FROM &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">DELETE FROM &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
<pre><code class="language-sql">INSERT INTO &quot;book_author&quot;
            (&quot;author&quot;,
              &quot;book&quot;,
              &quot;book_key&quot;)
VALUES      (?, /*2*/
              ?, /*2*/
              ?) /*0*/
</code></pre>
<pre><code class="language-sql">INSERT INTO &quot;book_category&quot;
            (&quot;book&quot;,
              &quot;category&quot;)
VALUES      (?, /*2*/
              ?) /*1*/
</code></pre>
</li>
</ol>
<h4><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h4>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  Optional&lt;Book&gt; poeaa = bookRepository.findById(this.poeaa.getId());
  assertThat(poeaa).hasValueSatisfying(equalTo(this.poeaa));
}
</code></pre>
<p>3 SQL queries are executed.</p>
<ol>
<li>
<p>Select book</p>
<pre><code class="language-sql">SELECT &quot;book&quot;.&quot;id&quot;               AS &quot;id&quot;,
       &quot;book&quot;.&quot;isbn&quot;             AS &quot;isbn&quot;,
       &quot;book&quot;.&quot;title&quot;            AS &quot;title&quot;,
       &quot;book&quot;.&quot;publication_date&quot; AS &quot;publication_date&quot;
FROM   &quot;book&quot;
WHERE  &quot;book&quot;.&quot;id&quot; = ? /*1*/
</code></pre>
</li>
<li>
<p>Select authors for the book</p>
<pre><code class="language-sql">SELECT &quot;book_author&quot;.&quot;author&quot;   AS &quot;author&quot;,
       &quot;book_author&quot;.&quot;book_key&quot; AS &quot;book_key&quot;
FROM   &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*1*/
ORDER  BY &quot;book_key&quot;
</code></pre>
</li>
<li>
<p>Select categories for the book</p>
<pre><code class="language-sql">SELECT &quot;book_category&quot;.&quot;category&quot; AS &quot;category&quot;
FROM   &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*1*/
</code></pre>
</li>
</ol>
<h4><a name="f34c8b22bd6fb5a16c60b7ecd412d675"></a><code>PagingAndSortingRepository.findAll(Pageable)</code></h4>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void findAllWithPageable() {
  Iterable&lt;Book&gt; result = bookRepository.findAll(
      PageRequest.of(0, 1, ASC, &quot;publication_date&quot;));
  List&lt;Book&gt; books = new ArrayList&lt;&gt;();
  result.forEach(books::add);

  assertThat(books)
      .hasSize(1)
      .satisfies(equalTo(this.poeaa), atIndex(0));
}
</code></pre>
<p>Query selects 1 book, so 4 SQL queries are executed.</p>
<ol>
<li>
<p>Select the 1st book ordering by publication date</p>
<pre><code class="language-sql">SELECT &quot;book&quot;.&quot;id&quot;               AS &quot;id&quot;,
       &quot;book&quot;.&quot;isbn&quot;             AS &quot;isbn&quot;,
       &quot;book&quot;.&quot;title&quot;            AS &quot;title&quot;,
       &quot;book&quot;.&quot;publication_date&quot; AS &quot;publication_date&quot;
FROM   &quot;book&quot;
ORDER  BY publication_date ASC
LIMIT  1 offset 0
</code></pre>
</li>
<li>
<p>Select authors for the book</p>
<pre><code class="language-sql">SELECT &quot;book_author&quot;.&quot;author&quot;   AS &quot;author&quot;,
       &quot;book_author&quot;.&quot;book_key&quot; AS &quot;book_key&quot;
FROM   &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*1*/
ORDER  BY &quot;book_key&quot;
</code></pre>
</li>
<li>
<p>Select categories for the book</p>
<pre><code class="language-sql">SELECT &quot;book_category&quot;.&quot;category&quot; AS &quot;category&quot;
FROM   &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*1*/
</code></pre>
</li>
<li>
<p>Count all books</p>
<pre><code class="language-sql">SELECT Count(*)
FROM   &quot;book&quot;
</code></pre>
</li>
</ol>
<h4><a name="fe9f09d7c10598e080ef1ac1502711df"></a><code>@Query</code> with SQL</h4>
<p>Spring Data JDBC is also a subject to &quot;N+1 selects problem&quot;.</p>
<p><code>com.example.spring.data.jdbc.repository.BookRepository</code></p>
<pre><code class="language-java">@Query(&quot;SELECT * FROM BOOK WHERE TITLE LIKE CONCAT('%', :title, '%')&quot;
    + &quot; ORDER BY PUBLICATION_DATE&quot;)
List&lt;Book&gt; findByTitleContains(String title);
</code></pre>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  List&lt;Book&gt; books = bookRepository.findByTitleContains(&quot;Pattern&quot;);
  assertThat(books)
      .hasSize(2)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1));
}
</code></pre>
<p>Query selects 2 books, so 5 SQL queries are executed.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT *
FROM   book
WHERE  title LIKE Concat('%', ?, '%') /*Pattern*/
ORDER  BY publication_date
</code></pre>
</li>
<li>
<p>Select authors for the 1st book from the result set</p>
<pre><code class="language-sql">SELECT &quot;book_author&quot;.&quot;author&quot;   AS &quot;author&quot;,
       &quot;book_author&quot;.&quot;book_key&quot; AS &quot;book_key&quot;
FROM   &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*1*/
ORDER  BY &quot;book_key&quot;
</code></pre>
</li>
<li>
<p>Select categories for the 1st book from the result set</p>
<pre><code class="language-sql">SELECT &quot;book_category&quot;.&quot;category&quot; AS &quot;category&quot;
FROM   &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*1*/
</code></pre>
</li>
<li>
<p>Select authors for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT &quot;book_author&quot;.&quot;author&quot;   AS &quot;author&quot;,
       &quot;book_author&quot;.&quot;book_key&quot; AS &quot;book_key&quot;
FROM   &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*2*/
ORDER  BY &quot;book_key&quot;
</code></pre>
</li>
<li>
<p>Select categories for the 2nd book from the result set</p>
<pre><code class="language-sql">SELECT &quot;book_category&quot;.&quot;category&quot; AS &quot;category&quot;
FROM   &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
</li>
</ol>
<h4><a name="ce75f4a17b574599267b2a18924cb931"></a><code>@Query</code> with SQL join</h4>
<p>Spring Data JDBC doesn't have a solution to &quot;N+1 selects problem&quot;.
<code>JOIN</code> in SQL query leads to duplicates in the result set.
Separate queries are still generated for <code>List&lt;AuthorRef&gt; authors</code> and <code>Set&lt;CategoryRef&gt; categories</code>.</p>
<p><code>com.example.spring.data.jdbc.repository.BookRepository</code></p>
<pre><code class="language-java">@Query(&quot;SELECT * FROM BOOK b&quot;
    + &quot; LEFT JOIN BOOK_AUTHOR ba ON b.ID = ba.BOOK&quot;
    + &quot; WHERE b.PUBLICATION_DATE &gt; :date&quot;)
List&lt;Book&gt; findByPublicationDateAfter(LocalDate date);
</code></pre>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void queryMethodWithJoin() {
  List&lt;Book&gt; books = bookRepository.findByPublicationDateAfter(LocalDate.parse(&quot;2000-01-01&quot;));
  assertThat(books)
      .hasSize(3)
      .satisfies(equalTo(this.poeaa), atIndex(0))
      .satisfies(equalTo(this.eip), atIndex(1))
      .satisfies(equalTo(this.eip), atIndex(2));
}
</code></pre>
<p>The EIP Book is present 2 times in the result list.
Duplicate is caused by join of the EIP Book with 2 Authors.
The POEAA Book has 1 author, so doesn't have duplicates in the result list.</p>
<h4><a name="59581bf130250c31253eac07da3d2c56"></a><code>@Query</code> with SQL and pagination</h4>
<p><code>com.example.spring.data.jdbc.repository.BookRepository</code></p>
<pre><code class="language-java">@Query(&quot;SELECT * FROM BOOK WHERE TITLE LIKE CONCAT('%', :title, '%')&quot;
    + &quot; ORDER BY PUBLICATION_DATE&quot;
    + &quot; OFFSET :start&quot;
    + &quot; FETCH NEXT :rowCount ROWS ONLY&quot;)
List&lt;Book&gt; findByTitleContains(String title, int start, int rowCount);

@Query(&quot;SELECT COUNT(*) FROM BOOK WHERE TITLE LIKE CONCAT('%', :title, '%')&quot;)
int countByTitleContains(String title);
</code></pre>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void queryMethodWithPagination() {
  String title = &quot;Pattern&quot;;
  Pageable pageRequest = PageRequest.of(1, 1); //0-based page number and page size
  List&lt;Book&gt; books = bookRepository.findByTitleContains(
      title, pageRequest.getPageNumber(), pageRequest.getPageSize());
  assertThat(books)
      .hasSize(1)
      .satisfies(equalTo(this.eip), atIndex(0));

  int count = bookRepository.countByTitleContains(title);
  assertThat(count).isEqualTo(2);

  Page&lt;Book&gt; page = new PageImpl&lt;&gt;(books, pageRequest, count);
  assertThat(page.getTotalPages()).isEqualTo(2);
  assertThat(page.getNumber()).isEqualTo(1);
  assertThat(page.getSize()).isEqualTo(1);
}
</code></pre>
<p>Query selects 1 book, so 4 SQL queries are executed.</p>
<ol>
<li>
<p>Select book</p>
<pre><code class="language-sql">SELECT   *
FROM     book
WHERE    title LIKE Concat('%', ?, '%') /*Pattern*/
ORDER BY publication_date offset ?FETCH next ? rows only /*1,1*/ 
</code></pre>
</li>
<li>
<p>Select authors for the book</p>
<pre><code class="language-sql">SELECT &quot;book_author&quot;.&quot;author&quot;   AS &quot;author&quot;,
       &quot;book_author&quot;.&quot;book_key&quot; AS &quot;book_key&quot;
FROM   &quot;book_author&quot;
WHERE  &quot;book_author&quot;.&quot;book&quot; = ? /*2*/
ORDER  BY &quot;book_key&quot; 
</code></pre>
</li>
<li>
<p>Select categories for the book</p>
<pre><code class="language-sql">SELECT &quot;book_category&quot;.&quot;category&quot; AS &quot;category&quot;
FROM   &quot;book_category&quot;
WHERE  &quot;book_category&quot;.&quot;book&quot; = ? /*2*/
</code></pre>
</li>
<li>
<p>Count books</p>
<pre><code class="language-sql">SELECT Count(*)
FROM   book
WHERE  title LIKE Concat('%', ?, '%') /*Pattern*/
</code></pre>
</li>
</ol>
<h3><a name="9a3347442ef97064c198bda69c16f816"></a>Locking strategies</h3>
<p><code>com.example.spring.data.jdbc.entity.BookRating</code></p>
<pre><code class="language-java">@Data
@AllArgsConstructor
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BookRating {

  @Id
  @With
  private Long id;

  @Version
  @With
  private final int version;

  @EqualsAndHashCode.Include
  private final Long book;

  private BigDecimal rating;

  private int numberOfRatings;

  public static BookRating of(Book book, BigDecimal rating, int numberOfRatings) {
    return new BookRating(null, 0, book.getId(), rating, numberOfRatings);
  }
}
</code></pre>
<h4><a name="272ede57357a5f214f2904c15e3fe103"></a>Implicit optimistic lock of entity with <code>@Version</code> on modification</h4>
<p>Spring Data JDBC supports optimistic locking by using <code>org.springframework.data.annotation.Version</code> annotation.
The behaviour is similar to JPA with <code>javax.persistence.Version</code> annotation.</p>
<p><code>com.example.spring.data.jdbc.BookRatingRepositoryTest</code></p>
<pre><code class="language-java">@Test
void implicitOptimisticLock() {
  assertThatThrownBy(() -&gt;
      doInNewTransaction(() -&gt; {
        BookRating ratingTx1 = bookRatingRepository.findById(this.rating.getId()).orElse(null);

        doInNewTransaction(() -&gt; {
          BookRating ratingTx2 = bookRatingRepository.findById(this.rating.getId()).orElse(null);

          assertThat(ratingTx2).isNotNull();
          assertThat(ratingTx2.getVersion()).isEqualTo(this.rating.getVersion());

          ratingTx2.setRating(ratingTx2.getRating().add(new BigDecimal(&quot;0.1&quot;)));
          ratingTx2.setNumberOfRatings(ratingTx2.getNumberOfRatings() + 1);

          bookRatingRepository.save(ratingTx2);
        });

        assertThat(ratingTx1).isNotNull();
        assertThat(ratingTx1.getVersion()).isEqualTo(this.rating.getVersion());

        ratingTx1.setRating(ratingTx1.getRating().add(new BigDecimal(&quot;0.2&quot;)));
        ratingTx1.setNumberOfRatings(ratingTx1.getNumberOfRatings() + 1);

        bookRatingRepository.save(ratingTx1);
      }))
      .isInstanceOf(DbActionExecutionException.class)
      .hasCauseInstanceOf(OptimisticLockingFailureException.class);

  BookRating rating = bookRatingRepository.findById(this.rating.getId()).orElse(null);

  assertThat(rating).isNotNull();
  assertThat(rating.getVersion()).isEqualTo(this.rating.getVersion() + 1);
  assertThat(rating.getRating())
      .isEqualByComparingTo(this.rating.getRating().add(new BigDecimal(&quot;0.1&quot;)));
  assertThat(rating.getNumberOfRatings()).isEqualTo(this.rating.getNumberOfRatings() + 1);
}
</code></pre>
<p>The following SQL queries are executed.</p>
<ol>
<li>
<p>Creating new transaction #1</p>
<pre><code class="language-sql">SELECT &quot;book_rating&quot;.&quot;id&quot;                AS &quot;id&quot;,
       &quot;book_rating&quot;.&quot;book&quot;              AS &quot;book&quot;,
       &quot;book_rating&quot;.&quot;rating&quot;            AS &quot;rating&quot;,
       &quot;book_rating&quot;.&quot;version&quot;           AS &quot;version&quot;,
       &quot;book_rating&quot;.&quot;number_of_ratings&quot; AS &quot;number_of_ratings&quot;
FROM   &quot;book_rating&quot;
WHERE  &quot;book_rating&quot;.&quot;id&quot; = ? /*1*/
</code></pre>
</li>
<li>
<p>Suspending current transaction #1, creating new transaction #2</p>
<pre><code class="language-sql">SELECT &quot;book_rating&quot;.&quot;id&quot;                AS &quot;id&quot;,
       &quot;book_rating&quot;.&quot;book&quot;              AS &quot;book&quot;,
       &quot;book_rating&quot;.&quot;rating&quot;            AS &quot;rating&quot;,
       &quot;book_rating&quot;.&quot;version&quot;           AS &quot;version&quot;,
       &quot;book_rating&quot;.&quot;number_of_ratings&quot; AS &quot;number_of_ratings&quot;
FROM   &quot;book_rating&quot;
WHERE  &quot;book_rating&quot;.&quot;id&quot; = ? /*1*/
</code></pre>
<pre><code class="language-sql">UPDATE &quot;book_rating&quot;
SET    &quot;version&quot; = ?, /*2*/
       &quot;book&quot; = ?, /*1*/
       &quot;rating&quot; = ?, /*4.500*/
       &quot;number_of_ratings&quot; = ? /*241*/
WHERE  &quot;book_rating&quot;.&quot;id&quot; = ? /*1*/
       AND &quot;book_rating&quot;.&quot;version&quot; = ? /*1*/
</code></pre>
</li>
<li>
<p>Initiating transaction #2 commit</p>
</li>
<li>
<p>Resuming suspended transaction #1 after completion of inner transaction #2</p>
<pre><code class="language-sql">UPDATE &quot;book_rating&quot;
SET    &quot;version&quot; = ?, /*2*/
       &quot;book&quot; = ?, /*1*/
       &quot;rating&quot; = ?, /*4.600*/
       &quot;number_of_ratings&quot; = ? /*241*/
WHERE  &quot;book_rating&quot;.&quot;id&quot; = ? /*1*/
       AND &quot;book_rating&quot;.&quot;version&quot; = ? /*1*/
</code></pre>
</li>
<li>
<p>Optimistic locking failed; nested exception is <code>org.springframework.dao.OptimisticLockingFailureException</code></p>
</li>
<li>
<p>Initiating transaction #1 rollback after exception</p>
</li>
</ol>
<h3><a name="532d5a8c2809912b992aa517d1e46ced"></a>Mapping from entity to DTO using MapStruct</h3>
<p><code>com.example.spring.data.jdbc.dto.BookDto</code></p>
<pre><code class="language-java">@Data
public class BookDto {

  private String isbn;
  private String title;
  private LocalDate publicationDate;
  private List&lt;AuthorDto&gt; authors = new ArrayList&lt;&gt;();
  private List&lt;CategoryDto&gt; categories = new ArrayList&lt;&gt;();
}
</code></pre>
<p><code>com.example.spring.data.jdbc.mapper.BookMapper</code></p>
<pre><code class="language-java">@Mapper(componentModel = &quot;spring&quot;)
@DecoratedWith(BookMapperDecorator.class)
public interface BookMapper {

  @Mapping(target = &quot;authors&quot;, ignore = true)
  @Mapping(target = &quot;categories&quot;, ignore = true)
  BookDto toBookDto(Book book);

  @Mapping(source = &quot;fullName&quot;, target = &quot;name&quot;)
  AuthorDto toAuthorDtos(Author author);

  @Mapping(source = &quot;name&quot;, target = &quot;label&quot;)
  CategoryDto toCategoryDto(Category category);

  List&lt;AuthorDto&gt; toAuthorDtos(List&lt;Author&gt; author);

  List&lt;CategoryDto&gt; toCategoryDtos(List&lt;Category&gt; category);
}
</code></pre>
<p><code>com.example.spring.data.jdbc.mapper.BookMapperDecorator</code></p>
<pre><code class="language-java">public abstract class BookMapperDecorator implements BookMapper {

  @Qualifier(&quot;delegate&quot;)
  @Autowired
  private BookMapper delegate;

  @Autowired
  private AuthorRepository authorRepository;

  @Autowired
  private CategoryRepository categoryRepository;

  @Override
  public BookDto toBookDto(Book book) {
    BookDto dto = delegate.toBookDto(book);
    dto.setAuthors(toAuthorDtos(authorRepository.findByBook(book.getId())));
    dto.setCategories(toCategoryDtos(categoryRepository.findByBook(book.getId())));
    return dto;
  }
}
</code></pre>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void mapToDto() {
  Optional&lt;BookDto&gt; eip = bookRepository.findById(this.eip.getId())
      .map(bookMapper::toBookDto);

  assertThat(eip).hasValueSatisfying(book -&gt; {
    assertThat(book.getIsbn()).isNotEmpty();
    assertThat(book.getTitle()).isNotEmpty();
    assertThat(book.getPublicationDate()).isNotNull();
    assertThat(book.getAuthors()).hasSize(2);
    assertThat(book.getCategories()).hasSize(2);
  });

  eip.ifPresent(dto -&gt; log.info(&quot;{}&quot;, dto));
}
</code></pre>
<h3><a name="fc1290b67d538903eba761ca9f952dc9"></a>Reactive <code>Mono.fromCallable</code> wrapping synchronous call</h3>
<p><code>com.example.spring.data.jdbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void reactiveWrapBlocking() {
  Mono&lt;Book&gt; blockingWrapper = Mono.fromCallable(() -&gt;
      bookRepository.findById(this.poeaa.getId()).orElse(null))
      .subscribeOn(Schedulers.boundedElastic());

  Book book = blockingWrapper.block();
  assertThat(book).satisfies(equalTo(this.poeaa));
}
</code></pre>
<h2><a name="1418b03e9a73d96a8c697855b6c0401e"></a>Spring Data R2DBC example</h2>
<p><a href="spring-data-r2dbc-examples/">spring-data-r2dbc-examples</a> has the same domain (book, author, category, rating) like Spring Data JPA example.</p>
<p><strong>UML class diagram</strong></p>
<p><img src="spring-data-r2dbc-examples/img/classes.png" alt="Actual UML class diagram"></p>
<p><strong>Entity-relationship diagram</strong></p>
<p><img src="spring-data-r2dbc-examples/img/tables.png" alt="Entity-relationship diagram"></p>
<p>Test data is the same like in Spring Data JDBC example.</p>
<h3><a name="cf43137803fb51915f84cbc5c3068d34"></a>Queries</h3>
<p><code>com.example.spring.data.r2dbc.BookRepositoryTest</code></p>
<h4><a name="4a2070d3aad7ff832b5e36f76cc6f731"></a><code>CrudRepository.findById</code></h4>
<p><code>com.example.spring.data.r2dbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void findById() {
  bookRepository.findById(this.poeaa.getId())
      .as(StepVerifier::create)
      .expectNextMatches(equalTo(this.poeaa))
      .verifyComplete();
}
</code></pre>
<p>A single SQL statement is executed</p>
<pre><code class="language-sql">SELECT book.*
FROM   book
WHERE  book.id = $1
LIMIT  2
</code></pre>
<h4><a name="74790cb9ca9d56e09b465befb7c7603b"></a>Query method with <code>Sort</code></h4>
<p><code>com.example.spring.data.r2dbc.repository.BookRepository</code></p>
<pre><code class="language-java">Flux&lt;Book&gt; findByTitleContains(String title, Sort sort);
</code></pre>
<p><code>com.example.spring.data.r2dbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void queryMethod() {
  bookRepository.findByTitleContains(&quot;Pattern&quot;, Sort.by(ASC, &quot;publicationDate&quot;))
      .as(StepVerifier::create)
      .expectNextMatches(equalTo(this.poeaa))
      .expectNextMatches(equalTo(this.eip))
      .verifyComplete();
}
</code></pre>
<p>A single SQL statement is executed</p>
<pre><code class="language-sql">SELECT book.id,
       book.isbn,
       book.title,
       book.publication_date
FROM   book
WHERE  book.title LIKE $1
ORDER  BY publication_date ASC
</code></pre>
<h4><a name="59581bf130250c31253eac07da3d2c56"></a><code>@Query</code> with SQL and pagination</h4>
<p>To create an instance of <code>org.springframework.data.domain.PageImpl</code> implementing <code>org.springframework.data.domain.Page</code>
a result set and total number of elements are required.</p>
<p>A result set and total number of elements can be merged into a <code>PageImpl</code> using
<code>Mono.zip(Mono&lt;? extends T1&gt;, Mono&lt;? extends T2&gt;, BiFunction&lt;? super T1,? super T2,? extends O&gt;)</code>.</p>
<p><code>com.example.spring.data.r2dbc.repository.BookRepository</code></p>
<pre><code class="language-java">@Query(&quot;SELECT * FROM BOOK WHERE TITLE LIKE CONCAT('%', :title, '%')&quot;
    + &quot; ORDER BY PUBLICATION_DATE&quot;
    + &quot; OFFSET :start&quot;
    + &quot; FETCH NEXT :rowCount ROWS ONLY&quot;)
Flux&lt;Book&gt; findByTitleContains(String title, int start, int rowCount, Sort sort);

@Query(&quot;SELECT COUNT(*) FROM BOOK WHERE TITLE LIKE CONCAT('%', :title, '%')&quot;)
Mono&lt;Integer&gt; countByTitleContains(String title);
</code></pre>
<p><code>com.example.spring.data.r2dbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void queryMethodWithPagination() {
  String title = &quot;Pattern&quot;;
  Pageable pageRequest = PageRequest.of(1, 1); //0-based page number and page size

  Mono.zip(
      bookRepository.findByTitleContains(title,
          pageRequest.getPageNumber(), pageRequest.getPageSize(),
          Sort.by(ASC, &quot;publicationDate&quot;))
          .collectList(),
      bookRepository.countByTitleContains(title),
      (books, count) -&gt; new PageImpl&lt;&gt;(books, pageRequest, count))
      .as(StepVerifier::create)
      .expectNextMatches(page -&gt;
          equalTo(this.eip).test(page.getContent().get(0))
              &amp;&amp; page.getTotalPages() == 2
              &amp;&amp; page.getNumber() == 1
              &amp;&amp; page.getSize() == 1)
      .verifyComplete();
}
</code></pre>
<p>2 SQL queries are executed.</p>
<ol>
<li>
<p>Select books</p>
<pre><code class="language-sql">SELECT   *
FROM     book
WHERE    title LIKE Concat('%', :title, '%')
ORDER BY publication_date offset :startFETCH next :rowCount rows only 
</code></pre>
</li>
<li>
<p>Count books</p>
<pre><code class="language-sql">SELECT Count(*)
FROM   book
WHERE  title LIKE Concat('%', :title, '%')
</code></pre>
</li>
</ol>
<h4><a name="532d5a8c2809912b992aa517d1e46ced"></a>Mapping from entity to DTO using MapStruct</h4>
<p>Fetching associations and mapping to DTO are not easy tasks with Spring Data R2DBC.
The parent entity has to be merged with its associations.
It can be done using
<code>Mono.zip(Mono&lt;? extends T1&gt;, Mono&lt;? extends T2&gt;, BiFunction&lt;? super T1,? super T2,? extends O&gt;)</code>.</p>
<p><code>Flux&lt;T&gt;</code> has to be collected into <code>Mono&lt;List&lt;T&gt;&gt;</code> using <code>Flux.collectList</code>.</p>
<p><code>com.example.spring.data.r2dbc.dto.BookDto</code></p>
<pre><code class="language-java">@Data
public class BookDto {

  private String isbn;
  private String title;
  private LocalDate publicationDate;
  private List&lt;AuthorDto&gt; authors = new ArrayList&lt;&gt;();
  private List&lt;CategoryDto&gt; categories = new ArrayList&lt;&gt;();
}
</code></pre>
<p><code>com.example.spring.data.r2dbc.mapper.BookMapper</code></p>
<pre><code class="language-java">@Mapper(componentModel = &quot;spring&quot;)
public interface BookMapper {

  @Mapping(target = &quot;authors&quot;, ignore = true)
  @Mapping(target = &quot;categories&quot;, ignore = true)
  BookDto toBookDto(Book book);

  @Mapping(source = &quot;fullName&quot;, target = &quot;name&quot;)
  AuthorDto toAuthorDtos(Author author);

  @Mapping(source = &quot;name&quot;, target = &quot;label&quot;)
  CategoryDto toCategoryDto(Category category);

  List&lt;AuthorDto&gt; toAuthorDtos(List&lt;Author&gt; author);

  List&lt;CategoryDto&gt; toCategoryDtos(List&lt;Category&gt; category);
}
</code></pre>
<p><code>com.example.spring.data.r2dbc.mapper.BookMappingService</code></p>
<pre><code class="language-java">@Transactional
@Service
public class BookMappingService {

  @Autowired
  private BookMapper bookMapper;

  @Autowired
  private AuthorRepository authorRepository;

  @Autowired
  private CategoryRepository categoryRepository;

  public Mono&lt;BookDto&gt; toBookDto(Book book) {
    BookDto bookDto = bookMapper.toBookDto(book);
    return Mono.zip(
        authorRepository.findByBook(book.getId()).collectList().map(bookMapper::toAuthorDtos),
        categoryRepository.findByBook(book.getId()).collectList().map(bookMapper::toCategoryDtos),
        (authorDtos, categorieDtos) -&gt; {
          bookDto.setAuthors(authorDtos);
          bookDto.setCategories(categorieDtos);
          return bookDto;
        });
  }
}
</code></pre>
<p><code>com.example.spring.data.r2dbc.BookRepositoryTest</code></p>
<pre><code class="language-java">@Test
void mapToDto() {
  bookRepository.findByTitleContains(&quot;Pattern&quot;, Sort.by(ASC, &quot;publicationDate&quot;))
      .flatMap(bookMappingService::toBookDto)
      .doOnNext(bookDto -&gt; log.info(&quot;{}&quot;, bookDto))
      .as(StepVerifier::create)
      .expectNextMatches(bookDto -&gt;
          Objects.equals(bookDto.getIsbn(), this.poeaa.getIsbn())
              &amp;&amp; Objects.equals(bookDto.getTitle(), this.poeaa.getTitle())
              &amp;&amp; Objects.equals(bookDto.getPublicationDate(), this.poeaa.getPublicationDate())
              &amp;&amp; bookDto.getAuthors().size() == 1
              &amp;&amp; bookDto.getCategories().size() == 2
      )
      .expectNextMatches(bookDto -&gt;
          Objects.equals(bookDto.getIsbn(), this.eip.getIsbn())
              &amp;&amp; Objects.equals(bookDto.getTitle(), this.eip.getTitle())
              &amp;&amp; Objects.equals(bookDto.getPublicationDate(), this.eip.getPublicationDate())
              &amp;&amp; bookDto.getAuthors().size() == 2
              &amp;&amp; bookDto.getCategories().size() == 2
      )
      .verifyComplete();
}
</code></pre>

</div>
    </div>
  </section>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-core.min.js" integrity="sha256-9h14mWYYiQGkeAKg2JtijbqApb56kgw57WN6sI6dwH0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-3S2PESHNt0YNL65z57WuHPHIv12fibpBDXepyCGHftw=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/plugins/custom-class/prism-custom-class.min.js" integrity="sha256-ubEwa1bEadlhCRqEVg7rO3VRU5gzqHAEE7pLAggldc8=" crossorigin="anonymous"></script>
  <script>
    Prism.plugins.customClass.prefix('prism-');
  </script>
</body>

</html>